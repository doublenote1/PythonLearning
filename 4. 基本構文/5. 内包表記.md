> Pythonで、既存のリスト(配列)の特定の条件を満たす要素のみを
  抽出・削除したり置換や変換などの処理をしたりして
  新たなリストを生成するには、リスト内包表記(List comprehension)を使う。

> 条件を満たす要素ではなく、ランダムに抽出することも可能。
[関連記事](../5.%20基本データ型/4.%20シーケンス型・集合型/7.%20要素の置換・抽出/リストからランダムに要素を選択するchoice,%20sample,%20choices.md)

> なお、リストは異なる型のデータを格納可能で、厳密には配列とは異なる。
  メモリサイズやメモリアドレスを必要とするような処理や
  大規模なデータの数値計算処理などで配列を扱いたい場合は
  array(標準ライブラリ)やNumPyを使う。
[note.nkmk.me](https://note.nkmk.me/python-list-array-numpy-ndarray/)

---------------------------------------------------------------------------

# 内包表記基本

>   * リスト内包表記
        `list型 = [<仮引数を含んだ新たな要素となる式>
        for <要素の仮引数> in <対象のイテラブル>]`
    * 集合内包表記
        リスト内包表記の [] が {} になる
    * ジェネレータ内包表記
        リスト内包表記の [] が () になる
    * 辞書内包表記
        `dict型 = {<キー: 値> の形に仮引数を含んだ新たな要素となる式>
        for <要素の仮引数> in <対象のイテラブル>}`

> リストやタプルなどの「イテラブルオブジェクト」の各要素を
  「仮引数」で取り出し式で評価、その結果が要素となる新たなリストが返される

## リスト内包表記

[関連記事](../5.%20基本データ型/4.%20シーケンス型・集合型/7.%20要素の置換・抽出/1.%20リスト内包表記.md)

## 集合内包表記

```python
lst = [1, 2, 3, 1, 2, 3]
print({x * 2 for x in lst})  # -> {2, 4, 6}
```

> 「集合」についての詳細は以下の記事を参照。
[関連記事](../5.%20基本データ型/4.%20シーケンス型・集合型/2.%20集合型.md)

## 辞書内包表記

```python
names = ['Alice', 'Bob', 'Charlie']
print({name: len(name) for name in names})
# -> {'Alice': 5, 'Bob': 3, 'Charlie': 7}
```

> キーと値それぞれのリストから新たな辞書を作成する場合は`zip()`関数を使う。
[関連記事](../5.%20基本データ型/4.%20シーケンス型・集合型/9.%20イテラブルを返す関数/zip()関数.md)

```python
keys = ['k1', 'k2', 'k3']
values = [1, 2, 3]

dic = {k: v for k, v in zip(keys, values)}
print(dic)  # -> {'k1': 1, 'k2': 2, 'k3': 3}

dic = {k: v for k, v in zip(keys, values) if v % 2 == 1}
print(dic)  # -> {'k1': 1, 'k3': 3}
```

## ジェネレータ式

```python
g = (i ** 2 for i in range(5))
print(g)  # -> <generator object <genexpr> at 0x10af944f8>
print(type(g))  # -> <class 'generator'>
print(list(g))  # -> [0, 1, 4, 9, 16]

"ジェネレータ式でもリスト内包表記と同様にifによる条件分岐やネストが可能"

g_cells = ((row, col) for row in range(0, 3)
           for col in range(0, 2) if col == row)
for i in g_cells:
    print(i)
# -> (0, 0)
# -> (1, 1)
```

> 例えば要素数が多いリストをリスト内包表記で生成して
  `for`文でまわすような場合、
  リスト内包表記を使うと最初に全要素を含むリストを生成するが、
  ジェネレータ式を使うとループが繰り返されるごとに
  要素が一つずつ生成されるので、メモリの使用量を抑えることができる

> ジェネレータ式を関数の「唯一の引数」とする場合は丸括弧`()`を省略できる

```python
"リスト内包表記"

print(sum([i**2 for i in range(5)]))  # -> 30

"ジェネレータ式(かっこの省略なし)"

print(sum((i**2 for i in range(5))))  # -> 30

"ジェネレータ式(かっこの省略あり)"

print(sum(i**2 for i in range(5)))  # -> 30
```

> タプル内包表記はないが、ジェネレータ式を`tuple()`の引数とすると
  内包表記の書き方でタプルを生成することが可能。

```python
t = tuple(i**2 for i in range(5))
print(t)  # -> (0, 1, 4, 9, 16)
print(type(t))  # -> <class 'tuple'>
```

# リンク

[note.nkmk.me](https://note.nkmk.me/python-list-comprehension/)
