> Pythonでは、新しいリストを生成するときに
  リスト内包表記(List comprehension)を使うとシンプルに書ける。

# 内包表記基本

>   * リスト内包表記
        `list型 = [<仮引数を含んだ新たな要素となる式>
         for <要素の仮引数> in <対象のイテラブル>]`
    * 集合内包表記
        リスト内包表記の [] が {} になる
    * ジェネレータ内包表記
        リスト内包表記の [] が () になる
    * 辞書内包表記
        `dict型 = {<キー: 値> の形に仮引数を含んだ新たな要素となる式>
         for <要素の仮引数> in <対象のイテラブル>}`

> リストやタプルなどの「イテラブルオブジェクト」の各要素を
  「仮引数」で取り出し式で評価、その結果が要素となる新たなリストが返される

## リスト

> 以降、等価のfor文とともに例を示す

```python
"=== 数値計算式で評価 ==="
"for文"
tmp = []
for x in range(-2, 3):
    tmp.append(x * 2)
print(tmp)  # -> [-4, -2, 0, 2, 4]
"内包表記"
print([x * 2 for x in range(-2, 3)])  # -> [-4, -2, 0, 2, 4]

"=== 関数で評価 ==="
"for文"
tmp = []
for x in range(-2, 3):
    tmp.append(abs(x))
print(tmp)  # -> [2, 1, 0, 1, 2]
"内包表記"
print([abs(x) for x in range(-2, 3)])  # -> [2, 1, 0, 1, 2]

"=== メソッドで評価 ==="
words = ['  aaa', '  bbb ', 'aaa bbb  ']
"for文"
tmp = []
for word in words:
    tmp.append(word.strip())
print(tmp)  # -> ['aaa', 'bbb', 'aaa bbb']
"内包表記"
print([word.strip() for word in words])  # -> ['aaa', 'bbb', 'aaa bbb']

"=== シーケーンスに組み込んで返す ==="
"for文"
tmp = []
for x in range(5):
    tmp.append((x, x ** 2))
print(tmp)# -> [(0, 0), (1, 1), (2, 4), (3, 9), (4, 16)]
"内包表記"
print([(x, x ** 2) for x in range(5)])
# -> [(0, 0), (1, 1), (2, 4), (3, 9), (4, 16)]

# TODO: どういう事かわからない
"式部分の関数のネスト"
from math import pi

print([str(round(pi, i)) for i in range(1, 6)])
# -> ['3.1', '3.14', '3.142', '3.1416', '3.14159']
```

### if文で要素をフィルタリング

`list型 = [<式> for <要素の仮引数> in <イテラブル> if <条件式>]`

> <条件式>が`True`となる<イテラブル>の要素のみ式で評価され、
  その結果が要素となる新たなリストが返される。
> <条件式>の中でも<仮引数>が使える。

> 以降、条件式に何を指定するかの例

```python
"=== <条件式>に「比較式」を指定 ==="
vec = [-4, -3, -2, -1, 0, 1, 2, 3, 4]
"for文"
tmp = []
for x in vec:
    if x >= 0:
        tmp.append(x)
print(tmp)  # -> [0, 1, 2, 3, 4]
"内包表記"
print([x for x in vec if x >= 0])  # -> [0, 1, 2, 3, 4]

print([x for x in vec if not x >= 0])  # -> [-4, -3, -2, -1]
print([x for x in vec if (x > 0) and (x % 2 == 0)])  # -> [2, 4]


str_l = ['oneXXXaaa', 'twoXXXbbb', 'three999aaa', '000111222']

"=== 特定の文字列を含む(含まない)かどうか ==="
print([s for s in str_l if 'XXX' in s])
# -> ['oneXXXaaa', 'twoXXXbbb']
print([s for s in str_l if 'XXX' not in s])
# -> ['three999aaa', '000111222']

"=== 特定の文字列で始まる(始まらない)かどうか ==="
print([s for s in str_l if s.startswith('t')])
# -> ['twoXXXbbb', 'three999aaa']
print([s for s in str_l if not s.startswith('t')])
# -> ['oneXXXaaa', '000111222']

"=== 特定の文字列で終わる(終わらない)かどうか ==="
print([s for s in str_l if s.endswith('aaa')])
# -> ['oneXXXaaa', 'three999aaa']
print([s for s in str_l if not s.endswith('aaa')])
# -> ['twoXXXbbb', '000111222']
```

### 三項演算子との組み合わせ

> 上の例では、条件を満たす要素のみが処理され、
  条件を満たさない要素は新たなリストから除外される。

> 条件によって処理を切り替えたい、
  `if`, `else`のように条件を満たさない要素には別の処理を行いたい場合は
  「三項演算子」を使う。

`list型 = [<真のときの値> if <条件式> else <偽のときの値>
for <要素の仮引数> in <イテラブル>]`

[](../4.%20制御フロー/3.%20if%20文・三項演算子.md)

```python
"=== 三項演算子で条件に応じて評価を変える ==="

"--- for文 ---"
tmp = []
for i in range(-2, 3):
    if i % 2 == 0:
        tmp.append('even')
    else:
        tmp.append('odd')
print(tmp)  # -> ['even', 'odd', 'even', 'odd', 'even']

"--- 内包表記 ---"
print(['even' if i % 2 == 0 else 'odd' for i in range(-2, 3)])
# -> ['even', 'odd', 'even', 'odd', 'even']
```

### ネストしたリスト内包表記

> `for`ループをネストするように、
  複数のイテラブルを組み合わせることもできる。

`[<式> for <変数名1> in <イテラブル1>
    for <変数名2> in <イテラブル2>
        for <変数名3> in <イテラブル3>]`

> 以降、等価なfor文とともに例を示す。

```python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

"=== for文 ==="
flat = []
for row in matrix:
    for x in row:
        flat.append(x)
print(flat)  # -> [1, 2, 3, 4, 5, 6, 7, 8, 9]

"=== 内包表記 ==="
flat = [x for row in matrix for x in row]
print(flat)  # -> [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

> 複数の仮引数を使うことも可能。

```python
"=== for文 ==="
cells = []
for row in range(3):
    for col in range(2):
        cells.append((row, col))
print(cells)  # -> # [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)]

"=== 内包表記 ==="
cells = [(row, col) for row in range(3) for col in range(2)]
print(cells)  # -> [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)]
```

> 条件分岐もできる。

```python
"=== for文 ==="
cells = []
for row in range(3):
    for col in range(2):
        if col == row:
            cells.append((row, col))
print(cells)

"=== 内包表記 ==="
cells = [(row, col) for row in range(3)
         for col in range(2) if col == row]
print(cells)
# [(0, 0), (1, 1)]
```

> それぞれのイテラブルに対して条件分岐することもできる。

```python
"=== for文 ==="
cells = []
for row in range(3):
    if row % 2 == 0:
        for col in range(2):
            if col % 2 == 0:
                cells.append((row, col))
print(cells)  # -> # [(0, 0), (2, 0)]

"=== 内包表記 ==="
cells = [(row, col) for row in range(3) if row % 2 == 0
         for col in range(2) if col % 2 == 0]
print(cells)  # -> # [(0, 0), (2, 0)]
```

### 「zip()」・「enumerate()」との組み合わせ

> `for`文でよく使われる便利な関数に、複数のイテラブルをまとめる`zip()`や
  インデックスとともに値を返す`enumerate()`がある。
[](../未整理/zip()関数.md)
[](../未整理/enumerate()関数.md)

> `zip()`や`enumerate()`をリスト内包表記で使うことももちろん可能。
  特殊な文法というわけではなく、`for`文との対応を考えれば難しくない。

```python
l_str1 = ['a', 'b', 'c']
l_str2 = ['x', 'y', 'z']

"=== zip()の例 ==="

"--- for文 ---"
l_zip = []
for s1, s2 in zip(l_str1, l_str2):
    l_zip.append((s1, s2))
print(l_zip) # -> [('a', 'x'), ('b', 'y'), ('c', 'z')]

"--- 内包表記 ---"
l_zip = [(s1, s2) for s1, s2 in zip(l_str1, l_str2)]
print(l_zip) # -> [('a', 'x'), ('b', 'y'), ('c', 'z')]

"=== enumerate()の例 ==="

"--- for文 ---"
l_enu = []
for i, s in enumerate(l_str1):
    l_enu.append((i, s))
print(l_enu) # -> [(0, 'a'), (1, 'b'), (2, 'c')]

"--- 内包表記 ---"
l_enu = [(i, s) for i, s in enumerate(l_str1)]
print(l_enu) # -> [(0, 'a'), (1, 'b'), (2, 'c')]


"ifを使う場合もこれまで通りの考え方"
l_zip_if = [(s1, s2) for s1, s2 in zip(l_str1, l_str2) if s1 != 'b']
print(l_zip_if)
# [('a', 'x'), ('c', 'z')]

"それぞれの要素を使って新たな要素を算出することもできる"
l_int1 = [1, 2, 3]
l_int2 = [10, 20, 30]

l_sub = [i2 - i1 for i1, i2 in zip(l_int1, l_int2)]
print(l_sub)
# [9, 18, 27]
```

## 集合

```python
lst = [1, 2, 3, 1, 2, 3]
print({x * 2 for x in lst})  # -> {2, 4, 6}
```

> 「集合」についての詳細は以下の記事を参照。
[](../3.5.%20基本データ型/3.%20リスト型・集合型/2.%20集合型.md)

## 辞書

```python
names = ['Alice', 'Bob', 'Charlie']
print({name: len(name) for name in names})
# -> {'Alice': 5, 'Bob': 3, 'Charlie': 7}
```

> キーと値それぞれのリストから新たな辞書を作成する場合は`zip()`関数を使う。
[](../未整理/zip()関数.md)

```python
keys = ['k1', 'k2', 'k3']
values = [1, 2, 3]

d = {k: v for k, v in zip(keys, values)}
print(d)  # -> {'k1': 1, 'k2': 2, 'k3': 3}
```

## ジェネレータ式

```python
g = (i ** 2 for i in range(5))
print(g)  # -> <generator object <genexpr> at 0x10af944f8>
print(type(g))  # -> <class 'generator'>
print(list(g))  # -> [0, 1, 4, 9, 16]

"ジェネレータ式でもリスト内包表記と同様にifによる条件分岐やネストが可能"
g_cells = ((row, col) for row in range(0, 3)
           for col in range(0, 2) if col == row)
for i in g_cells:
    print(i)
# -> (0, 0)
# -> (1, 1)
```

> 例えば要素数が多いリストをリスト内包表記で生成して
  `for`文でまわすような場合、
  リスト内包表記を使うと最初に全要素を含むリストを生成するが、
  ジェネレータ式を使うとループが繰り返されるごとに
  要素が一つずつ生成されるので、メモリの使用量を抑えることができる。

>> ジェネレータ式を関数の唯一の引数とする場合は丸括弧`()`を省略できる。

```python
"リスト内包表記"
print(sum([i**2 for i in range(5)]))  # -> 30
"ジェネレータ式(かっこの省略なし)"
print(sum((i**2 for i in range(5))))  # -> 30
"ジェネレータ式(かっこの省略あり)"
print(sum(i**2 for i in range(5)))  # -> 30
```

> タプル内包表記はないが、ジェネレータ式を`tuple()`の引数とすると
  内包表記の書き方でタプルを生成することが可能。

```python
t = tuple(i**2 for i in range(5))
print(t)  # -> (0, 1, 4, 9, 16)
print(type(t))  # -> <class 'tuple'>
```

# 様々なリストの作り方

## リストの要素を加工して生成

> `for`文

```python
squares = []
for x in range(5):
    squares.append(x ** 2)
print(squares)  # -> [0, 1, 4, 9, 16]
```

> `map()`関数とラムダ式

```python
squares = list(map(lambda x: x ** 2, range(5)))
print(squares)  # -> [0, 1, 4, 9, 16]
```

> リスト内包表記

```python
squares = [x ** 2 for x in range(5)]
print(squares)  # -> [0, 1, 4, 9, 16]
```

## 複数のリストの組み合わせ

> for 文

```python
combs = []
list1, list2 = [1, 2, 3], [1, 2, 3]
for x in list1:
    for y in list2:
        if x != y:
            combs.append((x, y))
print(combs)  # -> [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]
```

> for 文 itertools.product メソッド

```python
from itertools import product as multi_iter

combs = []
list1, list2 = [1, 2, 3], [1, 2, 3]
for x, y in multi_iter(list1, list2):
    if x != y:
        combs.append((x, y))
print(combs)  # -> [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]
```

> リスト内包表記

```python
list1, list2 = [1, 2, 3], [1, 2, 3]

combs = [(x, y) for x in list1 for y in list2 if x != y]
print(combs)  # -> [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]
```

# リンク

[](https://note.nkmk.me/python-list-comprehension/)
