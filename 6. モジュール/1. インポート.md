# インポート関連用語

> ・ モジュール:
        関数やクラスの定義を集めた拡張子が`.py`や`pyc`のスクリプトファイル
  ・ パッケージ:
        通常のパッケージ: 関係のある複数のモジュールと`__init__.py`を
            ディレクトリ内にまとめたもの
        名前空間パッケージ: 「通常のパッケージ」から
            `__init__.py`を省いたもの
  ・ ライブラリ:
        モジュールやパッケージのことをライブラリと呼ぶ場合もある
  ・ オブジェクト:
        このファイルのコメント内では、
        アクセス可能なモジュール内の関数や変数を示す
  ・ モジュール検索パス:
        インポートするときに探索されるパス

# パスの通ったディレクトリ直下からインポート

> 以下のように`import <モジュール名>`とすると
  モジュールが「module型」のオブジェクトとしてインポートされる。

## モジュールをインポート

> `print(<モジュール名>)`で出力すると
  どのファイルを読み込んでいるかが確認できる。

```python
"標準ライブラリ直下から"
import math

print(type(math))  # -> <class 'module'>
print(math)  # -> <module 'math' (built-in)>

"カレントディレクトリ直下から"
import mod_1

print(type(mod_1))  # -> <class 'module'>
print(mod_1)  # -> <module 'math' (built-in)>
```

> モジュールをインポートすると、
  `<モジュール名>.<関数名>`、`<モジュール名>.<変数名>`のように
  モジュール内で定義された関数やグローバル変数などを使用できる。

```python
"標準ライブラリ直下から"
import math

print(math.radians(180))  # -> 3.141592653589793
print(type(math.radians))  # -> <class 'builtin_function_or_method'>
print(math.pi)  # -> 3.141592653589793
print(type(math.pi))  # -> <class 'float'>

"カレントディレクトリ直下から"
import mod_1

mod_1.func_1()  # -> mod_1.func1
```

## モジュールのオブジェクトをインポート

> `from`を使って、
  モジュールで定義されたオブジェクト(関数や変数、クラスなど)を指定して
  インポートすることができる。

### 単独のオブジェクト

> インポートしたオブジェクトは<オブジェクト名>で直接使用できる。
> インポートされるのは指定したオブジェクトのみで
  モジュール自体はインポートされない。
  他のオブジェクトを使用しようとするとエラーNameErrorになる。

```python
"標準ライブラリ直下から"
from math import pi

print(pi)  # -> 3.141592653589793

try:
    print(math.radians(180))
except NameError as e:
    print(e)  # -> name 'math' is not defined

"カレントディレクトリ直下から"
from mod_1 import func_1

func_1()  # -> mod_1.func1
```

### 複数のオブジェクト

```python
"標準ライブラリ直下から"
from math import pi, radians

print(pi)  # -> 3.141592653589793
print(radians(180))  # -> 3.141592653589793

"""多数のオブジェクトをインポートして一行が長くなってしまう場合は、
括弧()を使えば改行して書ける。"""

from math import (
    e,
    exp
)

print(e)  # -> 2.718281828459045
print(exp(1))  # -> 2.718281828459045

"カレントディレクトリ直下から"
from mod_1 import func_1, func_2

func_1()  # -> mod_1.func1
func_2()  # -> mod_1.func2
```

### モジュルー内のオブジェクトを全て

```python
"標準ライブラリ直下から"
from math import *

print(pi)  # -> 3.141592653589793
print(cos(0))  # -> 1.0
print(sin(0))  # -> 0.0

"カレントディレクトリ直下から"
from mod_1 import *

func_1()
func_2()
func_3('test')
```

# パッケージ内からインポート


## パッケージとは

> パッケージを使うと、
  関係のある複数のモジュールをフォルダにまとめ、
  整理することができます。

> 通常はモジュールを使用するときには
  モジュールが入ったディレクトリにPATHが通ってなければなりません。
  しかし、パッケージの機能を使うと、インポートするときに、
  モジュールが入ったディレクトリにPATHが通ってなくても、
  ディレクトリ名と半角ピリオド`.`を用いて、
  モジュールの位置を指定することができるようになります。

> 例として、以下の図ようなフォルダ構成のパッケージがあったとします。
  この例では「モジュール」フォルダにはPATHが通っているという設定ですので、
  モジュール`main.py`はフィル名を指定して実行することは可能です。
  しかし、ディレクトリ`pkg`や`sub_pkg`にはPATHが通っていませんので、
  パッケージの機能を使わなければ、
  その中にあるモジュール`sub_pkg_mod.py`は指定することができません。

> python_code  <- PATHが通っている
  ┣━ main.py
  ┗━ pkg
       ┣━ __init__.py
       ┗━ sub_pkg
            ┣━ __init__.py
            ┗━ sub_pkg_mod.py

> この例ではディレクトリ`pkg`と`sub_pkg`には`__init__.py`を入れ、
  パッケージであることを明示しています。
  ディレクトリに`__init__.py`を入れることで、
  そのディレクトリ名を使ってimport文を記述することができます。
  具体的には`import pkg.sub_pkg.sub_pkg_mod`という記述が可能になります。
  なお、`__init__.py`はコードを全く記述しない空のファイルでもかまいませんが、
  コードを記述することもできます。

> ※Python3.3からは、名前空間パッケージ(ネームスペースパッケージ)を
  用いることにより、`__init__.py`がなくても同様の事ができる様になりました。
  ですから、`__init__.py`がなくてもエラーにはなりません。
  しかし、通常のパッケージ(レギュラーパッケージ)には
  `__init__.py`が必要ですので、必要なものとして読み進めてください。

## パッケージからインポートする為の2つの書式

> パッケージ内のモジュールをインポートする書式には2種類あります。
  具体的な例でインポートの仕方を説明します。

### 書式１

`import ○○.△△.□□`

> １つめは`import ○○.△△.□□`という書式です。
  最後の□□はモジュール(あるいはパッケージ)にする必要があり、
  クラス、関数、変数にはできません。
  すると、必然的にその前の○○や△△は、パッケージになります。
> なお、この書式で読み込んだモジュールを使用するときは、
  ○○.△△.□□としなければなりません。
  ○○や△△は省略することはできません。

> 下記コードは、モジュール`sub_pkg_mod`の関数`func_1`を、
  `main.py`からインポートし、実行したコードです。 
  `○○.△△.□□.関数名()`、`xxx = ○○.△△.□□ →  xxx.関数名()`
  といった書式で実行しています。
  実行例3のように、pkg.sub_pkg.を省略することはできません。

```python
import pkg.sub_pkg.sub_pkg_mod

pkg.sub_pkg.sub_pkg_mod.func_1()

"関数の実行例2"
xxx = pkg.sub_pkg.sub_pkg_mod
xxx.func_1()

"関数の実行例3(エラー)"
"pkg.sub_pkg.を省略することはできません。"
try:
    sub_pkg_mod.func_1()
except NameError as e:
    print(e)  # -> name 'mod_1' is not defined
```

#### PATHが通っていないディレクトリの扱い

> ディレクトリに`__init__.py`を入れることにより、
  どこからでも呼び出せるようになるわけではありません。
  下記のコードは`import sub_pkg.sub_pkg_mod_1`としていますが、
  ディレクトリ`sub_pkg`が入っているディレクトリ`pkg`には
  PATHが通っていませんので、`pkg.`を省略することはできません。
  以下の例はエラーになります。

```python
"sub_pkgが入っているpkgにPATHが通っていない。"
try:
    import sub_pkg.sub_pkg_mod_1
except ModuleNotFoundError as e:
    print(e)  # -> No module named 'sub_pkg'
```

#### モジュールではなく、パッケージをインポートした場合

> `import ○○.△△.□□`の書式は、
  □□をパッケージやモジュールにできるといいましたが、
  □□をパッケージとした場合、ディレクトリ□□の中のモジュールには
  アクセスできません。
> パッケージをインポートした場合は、ディレクトリ□□の中の`__init__.py`に、
  必要なモジュールをインポートするコードを記述する
  といった使い方をしなければ、使い方が限定されると思われます。

> 下記のコードは、パッケージの`sub_pkg`をインポートした例ですが、
  実行例1、実行例2のように`sub_pkg`の中のモジュールを呼び出そうとすると
  エラーになります。
  ただ、実行例3では`<class ‘module’>`が出力されますので、
  `pkg.sub_pkg`がインポートされていないわけではありません。

```python
import pkg.sub_pkg

"関数の実行例1(エラー)"
"sub_pkgの中のモジュールはインポートされていない。"
try:
    pkg.sub_pkg.sub_pkg_mod.func_1()
except AttributeError as e:
    print(e)  # -> module 'pkg.sub_pkg' has no attribute 'sub_pkg_mod'

"関数の実行例2(エラー)"
"sub_pkgの中のモジュールはインポートされていない。"
try:
    xxx = pkg.sub_pkg.sub_pkg_mod
except AttributeError as e:
    print(e)  # -> module 'pkg.sub_pkg' has no attribute 'sub_pkg_mod'
xxx.func_1()

"関数の実行例3"
"<class 'module'>が出力される。"
print(type(pkg.sub_pkg))  # -> <class 'module'>
```

### 書式2

`from ○○.△△ import □□`

> 書式2`from ○○.△△ import □□`では、importの後の□□の部分は、
  △△.□□のようにドットが入る書式にはできません。
  したがって、`from ○○.△△ import □□`を`from ○○ import △△.□□`
  とは書き換えられません。
  なお、□□は、書式1と異なり、パッケージ、モジュール、クラス、関数、変数の
  どれでもかまいません。

> モジュールを実行するときは、インポートの後の□□を使います。
  ○○.△△.□□とすると、エラーになります。

```python
from pkg.sub_pkg import sub_pkg_mod

"関数の実行例1"
sub_pkg_mod.func_1()

"関数の実行例2(エラー)"
"fromのあとのpkg.sub_pkgは記述できない。"
try:
    pkg.sub_pkg.sub_pkg_mod.func_1()
except NameError as e:
    print(e)  # -> name 'sub_pkg_mod' is not defined
```

## 「__init__.py」が実行されるタイミング

> モジュールはインポートしたときに一度だけ、
  モジュール内のコードを実行します。
  その性質を使って、`__init__.py`が、どのタイミングでインポート
  されるのかを確認します。
  フォルダ構成と各モジュールのコードは以下のようになっています。

```python
print('■メインモジュールmainのコード開始')

from pkg.sub_pkg.sub_pkg_mod import func_1

print('■メインモジュールmainのimport文実行完了')
func_1()
print('■メインモジュールmainの__name__→',__name__)
print('■メインモジュールmainのコード終了')
```

> 出力05

■メインモジュールmainのコード開始
ディレクトリpkgの中の__init__.py
ディレクトリsub_pkgの中の__init__.py
モジュールmod_1の__name__→ pkg.sub_pkg.mod_1
■メインモジュールmainのimport文実行完了
モジュールmod_1の関数func_1
■メインモジュールmainの__name__→ __main__
■メインモジュールmainのコード終了

> 結果から言うと、import文の中で、その`__init__.py`が入った
  ディレクトリの名称が使われるときに実行されます。
  上の「コード05」では、`from pkg.sub_pkg.mod_1 import func_1`の
  `pkg.sub_pkg.`の部分により、`pkg`, `sub_pkg`の`__init__.py`が実行されます。
> 出力05では、`__init__.py`のインポートは
  コード05の1行目のprint文よりも後に実行されています。
  ですから、コードが実行される前にまとめて
  `__init__.py`が処理されるわけではありません。
> 次に、`pkg`, `sub_pkg`の`__init__.py`が実行されたあとに、
  コード05の`from pkg.sub_pkg.mod_1 import func_1`」の
  `.mod_1`の部分により、モジュール`mod_1`のコードが実行されています。
  コード05の3行目は、モジュール`mod_1`ではなく、
  関数の`func_1`をインポートする命令文なのですが、
  モジュール`mod_1`のコードが実行されています。
> なお、`func_1`は、モジュールではなく関数ですので、
  インポートされるときに関数の中のコードは実行されません。

> その他にも、メインモジュールである`main.py`の
  `__name__`が`__main__`になっているのに対して、
  モジュール`mod_1`の`__name__`が`pkg.sub_pkg.mod_1`に
  なっている点が注目ポイントです。
  モジュールの`__name__`は、
  メインモジュールとして実行したときには`__main__`となり、
  import文でインポートした時には「モジュール名」となります。
> パッケージを用いて読み込んだ場合には、
  モジュール名`mod_1`だけではなく、
  モジュールの位置がわかるように`pkg.sub_pkg.mod_1`となっています。

## 絶対インポートと相対インポート

> importによるモジュールの位置の指定には、
  「絶対import」と「相対import」があります。
  今までの具体例は、全て「絶対import」です。
> たとえば`from pkg.sub_pkg.mod_1 import func_1`のように、
  PATHが通っているディレクトリ内のパッケージ`pkg`から
  始まる記述になっています。
> 一方、「カレントディレクトリ」からの相対位置によって
  モジュールの位置を示すのが「相対import」です。
 「相対import」では、以下の様にピリオド「.」を用いて相対位置を表現します。

> `.`: カレントディレクトリ
  `..`: 親ディレクトリ
  `…`: 親ディレクトリの親ディレクトリ
  `….`: 親ディレクトリの親ディレクトリの親ディレクトリ

### 相対importの具体的な書式

> 例えば下の図のようなフォルダ(ディレクトリ)構成で、
  図の右に示すようなコードが記述されているとします。
  この場合、モジュール`sub_pkg_mod2`からモジュール`mod_1`や
  関数`func_1`をインポートするときは、コード06のようになります。
> 呼び出し元のモジュール`sub_pkg_mod2`が存在するディレクトリ`sub_pkg`が
  カレントディレクトリになります。
> `from . import mod_1`の`.`は、
 「絶対import」では`pkg.sub_pkg`に相当します。
> なお「相対import」は、
  書式2`from ○○.△△ import □□`では使用できますが、
  書式1`import ○○.△△.□□`では使用できず、エラーとなります。

> python_code  <- PATHが通っている
  ┣━ main.py
  ┗━ pkg
       ┣━ __init__.py
       ┣━ pkg_mod1.py
       ┗━ sub_pkg
            ┣━ __init__.py
            ┣━ mod_1.py
            ┗━ sub_pkg_mod2.py

> コード06
```python
#インポート例1
from . import mod_1

#インポート例2
from .mod_1 import func_1 

#インポート例3(エラー)
#「import ○○.△△.□□」タイプは使えない
import .mod_1
```

次に、モジュールsub_pkg_mod2からモジュールpkg_mod1や関数pkg_def1をimportする例をコード07の示します。「..」は呼び出し元のモジュールsub_pkg_mod2のカレントディレクトリ(sub_pkg)の親のディレクトリ(pkg)を示します。したがって、コード06の4行目「from .. import pkg_mod1」の「..」は絶対importの「pkg」に相当します。

#コード07

#インポート例1
from .. import pkg_mod1

#インポート例2
from ..pkg_mod1 import pkg_def1

#インポート例3(エラー)
#「import ○○.△△.□□」タイプは使えない
import ..pkg_mod1

(2) 相対importの実行例

以下、具体的な実行例を示します。

以下、main.py(コード08a)、sub_pkg_mod2.py(コード08b)のコードと、main.pyの実行結果を出力08に示します。どの様な順番で実行されているのかが、出力08を見ればわかると思います。なお、min_mod.pyの出力には「■」、sub_pkg_mod2.pyの出力には「□」を出力の頭につけました。

#コード08a(main.py)
print('■メインモジュールmainのコード開始')

from pkg.sub_pkg.sub_pkg_mod2 import sub_pkg_def2

print('■メインモジュールmainのimport文実行完了')
sub_pkg_def2()
print('■メインモジュールmainの__name__→',__name__)
print('■メインモジュールmainのコード終了')

#コード08b(sub_pkg_mod2.py)
print('□sub_pkg_mod2の一番最初')

from .. import pkg_mod1
from .mod_1 import func_1

def sub_pkg_def2():
    print('□モジュールsub_pkg_mod2の関数sub_pkg_def2')
    
pkg_mod1.pkg_def1()
func_1()
print('□モジュールsub_pkg_mod2の__name__→',__name__)

#出力08
■メインモジュールmainのコード開始
ディレクトリpkgの中の__init__.py
ディレクトリsub_pkgの中の__init__.py
□sub_pkg_mod2の一番最初
モジュールpkg_mod1の__name__→ pkg.pkg_mod1
モジュールmod_1の__name__→ pkg.sub_pkg.mod_1
モジュールpkg_mod1の関数pkg_def1
モジュールmod_1の関数func_1
□モジュールsub_pkg_mod2の__name__→ pkg.sub_pkg.sub_pkg_mod2
■メインモジュールmainのimport文実行完了
□モジュールsub_pkg_mod2の関数sub_pkg_def2
■メインモジュールmainの__name__→ __main__
■メインモジュールmainのコード終了

(3) メインモジュールには相対importは使えない

メインモジュール(main.py)に下記のような相対importは使用できません。相対importを使うと、出力09のようなエラーが発生します。
上の出力08の13行目を見るとわかりますが、モジュールをメインモジュールとして使う場合には、変数__name__には’__main__’という文字列が代入されます。そして、相対importでは、この’__main__’という文字列がカレントディレクトリの位置を示す文字列として認識されます。しかし、’__main__’は、モジュールの位置を示す名称とは扱えないので、「’__main__’がパッケージではない」というエラーが発生したのです。
出力08の6, 7, 10行目のように、import文によりインポートされたモジュールは、変数__name__に、カレントディレクトリの位置を示す文字列が代入されるので、相対importを使うことができます。

#コード09(エラー)
#メインモジュール(main.py)では相対importは使用できない。
from .sub_pkg.sub_pkg_mod2 import sub_pkg_def2

#出力09
ModuleNotFoundError: No module named '__main__.sub_pkg'; '__main__' is not a package

## 「from ○○.△△ import *」の利用

自分が用意したパッケージで、「from ○○.△△ import *」のような書式で「*(アスタリスク)」を使って、ディレクトリ内のモジュールを一度にインポートしようとしても、複数のモジュールを読み込むための準備をしなければ、なにもimportできません。
つまり、それなりの準備をすれば、複数のモジュールを一度にインポートできますが、不特定多数のモジュールがインポートされてしまうこの方法は、推奨されていませんので、極力避けるようにしてください。

(1) 「import *」だけでは何もインポートできない

下のようなディレクトリ(フォルダ)構成のパッケージがあったとします。そして、main.pyのコードがコード11のように、単純にモジュールsub_pkg_mod2を読み込むだけのコードを実行すると、出力11のように出力され、モジュールsub_pkg_mod2がインポートされていることがわかります。

#コード11(main.py)
from pkg.sub_pkg import sub_pkg_mod2

#出力11
ディレクトリpkgの中の__init__.py
ディレクトリsub_pkgの中の__init__.py
モジュールsub_pkg_mod2の__name__→ pkg.sub_pkg.sub_pkg_mod2

次に、importの後を「*」にしてみます。今度は、出力12より、ディレクトリsub_pkg内のモジュールmod_1, sub_pkg_mod2は、どちらもインポートされていないことがわかります。「import *」を使って「モジュール」を読み込むのはこれだけではできません。

#コード12(main.py)
from pkg.sub_pkg import *

#出力12
ディレクトリpkgの中の__init__.py
ディレクトリsub_pkgの中の__init__.py

なお、ここで、混同してはならないのは、「モジュール」ではなく、「関数」ならば「import *」により読み込み可能です。例えばmain.pyのimport を、「from pkg.sub_pkg.mod_1 import *」とすれば、モジュールmod_1の中の関数「func_1()」を、関数名だけで呼び出せるようになります。

さて、話を元に戻しますが、それでは、どのようにすれば「import *」により、モジュールを読み込むことができるのでしょうか。以下、２つの使い方をご紹介します。

(2)  使い方1：先にimportしたモジュールをimport

先に「import ○○.△△.□□」でimportしたモジュールを「from ○○.△△ import *」でインポートすると、モジュールを呼び出すときに○○.△△の部分を省略できます。
コード13では、5行目の関数の実行部分で、「pkg.sub_pkg.sub_pkg_mod2.sub_pkg_def2」とする必要があり、エラーになります。

#コード13(main.py)(エラー)
#関数の実行では、pkg.sub_pkg.sub_pkg_mod2.sub_pkg_def2 とする必要がある。
import pkg.sub_pkg.sub_pkg_mod2

sub_pkg_mod2.sub_pkg_def2()

それに対して、コード14のように、「import pkg.bbb.sub_pkg_mod2」のあとに「from pkg.sub_pkg import *」とすると、「pkg.sub_pkg.」は不要となり、「sub_pkg_mod2.sub_pkg_def2()」で、関数を実行することができました。

#コード14(main.py)
import pkg.sub_pkg.sub_pkg_mod2
from pkg.sub_pkg import *

sub_pkg_mod2.sub_pkg_def2()

#出力14
ディレクトリpkgの中の__init__.py
ディレクトリsub_pkgの中の__init__.py
モジュールsub_pkg_mod2の__name__→ pkg.sub_pkg.sub_pkg_mod2
モジュールsub_pkg_mod2の関数sub_pkg_def2

(3) 使い方2：__init__.pyに「__all__=リスト」を記述

「import *」を用いて、複数のモジュールを読み込む方法として、__init__.pyの中に「__all__=読み込みたいモジュール名のリスト」を書き込む方法があります。

コード15a(main.py)と、コード15b(ディレクトリsub_pkgの中の__init__.py)を見てください。ディレクトリsub_pkgの中の「__init__.py」に、「__all__=[‘mod_1’, ‘sub_pkg_mod2’]」を書き込むと、main.pyの中から「from pkg.sub_pkg import *」とすることで、複数のモジュールをインポートすることができました。

#コード15a(main.py)
from pkg.sub_pkg import *

#コード15b(ディレクトリsub_pkgの中の__init__.py)
print('ディレクトリsub_pkgの中の__init__.py')
__all__=['mod_1', 'sub_pkg_mod2']

#出力15
ディレクトリpkgの中の__init__.py
ディレクトリsub_pkgの中の__init__.py
モジュールmod_1の__name__→ pkg.sub_pkg.mod_1
モジュールsub_pkg_mod2の__name__→ pkg.sub_pkg.sub_pkg_mod2

なお、参考までに、コード16aのように、「import pkg.sub_pkg」だけでは、「__all__=モジュールのリスト」で指定したモジュールはインポートされません。(コード16bはコード15bと同じ内容)

#コード16a(main.py)
import pkg.sub_pkg

#コード16b(ディレクトリsub_pkgの中の__init__.py)
print('ディレクトリsub_pkgの中の__init__.py')
__all__=['mod_1', 'sub_pkg_mod2']

#出力16
ディレクトリpkgの中の__init__.py
ディレクトリsub_pkgの中の__init__.py

## __init__.pyの中でimportする方法

__init__.pyの中で、複数のモジュールをimportする方法もあります。この方法であれば、相対importや絶対importにより、様々な場所のモジュールをインポートすることが可能です。
ただし、この方法は、「__all__」を使う方法よりも、更に不特定多数のモジュールがインポートされてしまいますので、極力、使用を避けたい方法です。

(1) __init__.pyが入ったパッケージをimportする方法

下のようなディレクトリ構成のパッケージを想定します。この中で、ディレクトリsub_pkgの中の__init__.pyに、import文を記述します。

ディレクトリsub_pkgの中の__init__.pyのコードはコード17bのようになっており、モジュールpkg_mod1, mod_1, sub_pkg_mod2をimportするためのimport文が記述されています。そして、このコード17bを実行するためには、 コード17aのように「import pkg.sub_pkg」とし、パッケージsub_pkgをインポートします。
この方法でimportしたモジュールは、モジュール名だけでは実行できず、「pkg.sub_pkg.sub_pkg_mod2.sub_pkg_def2()」「pkg.pkg_mod1.pkg_def1()」といった書式で、関数を実行します。

#コード17a(main.py)
import pkg.sub_pkg

pkg.sub_pkg.sub_pkg_mod2.sub_pkg_def2()
#sub_pkg.sub_pkg_mod2.sub_pkg_def2() #エラー
#sub_pkg_mod2.sub_pkg_def2() #エラー

pkg.pkg_mod1.pkg_def1()
#pkg_mod1.pkg_def1() #エラー

#コード17b(ディレクトリsub_pkgの中の__init__.py)
print('ディレクトリsub_pkgの中の__init__.py')
from . import mod_1
from . import sub_pkg_mod2
from .. import pkg_mod1

#出力17
ディレクトリpkgの中の__init__.py
ディレクトリsub_pkgの中の__init__.py
モジュールmod_1の__name__→ pkg.sub_pkg.mod_1
モジュールsub_pkg_mod2の__name__→ pkg.sub_pkg.sub_pkg_mod2
モジュールpkg_mod1の__name__→ pkg.pkg_mod1
モジュールsub_pkg_mod2の関数sub_pkg_def2
モジュールpkg_mod1の関数pkg_def1

(2) 「import *」を使用する方法

ディレクトリの構成は先ほどの例と同じです。メインモジュールであるmainのコードのみ、記述内容を変えます。

ディレクトリsub_pkgの中の__init__.pyのコードは先ほどと同じで、コード18bのようになっており、モジュールpkg_mod1, mod_1, sub_pkg_mod2をimportするためのimport文が記述されています。ただ、今度は、このコード18bを実行するために、 コード18aのように「from pkg.sub_pkg import *」としました。
この方法でimportしたモジュールは、モジュール名だけで実行できでき、モジュール名の前にパッケージ名を加えるとエラーになります。

#コード18a(main.py)
from pkg.sub_pkg import *

#pkg.sub_pkg.sub_pkg_mod2.sub_pkg_def2() #エラー
#sub_pkg.sub_pkg_mod2.sub_pkg_def2() #エラー
sub_pkg_mod2.sub_pkg_def2()

#pkg.pkg_mod1.pkg_def1() #エラー
pkg_mod1.pkg_def1()

#コード18b(ディレクトリsub_pkgの中の__init__.py)
print('ディレクトリsub_pkgの中の__init__.py')
from . import mod_1
from . import sub_pkg_mod2
from .. import pkg_mod1

#出力18
ディレクトリpkgの中の__init__.py
ディレクトリsub_pkgの中の__init__.py
モジュールmod_1の__name__→ pkg.sub_pkg.mod_1
モジュールsub_pkg_mod2の__name__→ pkg.sub_pkg.sub_pkg_mod2
モジュールpkg_mod1の__name__→ pkg.pkg_mod1
モジュールsub_pkg_mod2の関数sub_pkg_def2
モジュールpkg_mod1の関数pkg_def1

## 通常のパッケージと名前空間パッケージ

通常のパッケージ(レギュラーパッケージ)と名前空間パッケージ(ネームスペースパッケージ)の実用的な部分での違いを簡単に説明します。なお、明快な通常のパッケージを利用することをお勧めします。

[a007]
(1) 通常のパッケージの利点

(a) __init__.pyの中に「__all__=[モジュールのリスト]」という書式で一度にimportしたいモジュールを列挙することができる。
(b) __init__.pyの中にimport文を記述することができる。
(c) __init__.pyが入っていれば、パッケージであることが判別できる。

[a007_01]
(2) 名前空間パッケージの利点

(a) __init__.pyを省略できる。
(b) PATHが通っているところに、同じ名前のディレクトリが存在した場合でも、それぞれの同名のディレクトリの中にあるモジュールを指定することができる。ただし、これは、メリットでもあり、デメリットでもある。(通常のパッケージではエラーになるため、ディレクトリ名の重複をさけることができる。)

Python
シェアする
Twitter
Facebook
はてブ
Pocket
LINE
管理者をフォローする
管理者
関連記事
Python
Python♪「% 演算子」の書式設定において、桁数を「*」で表記する方法
%演算子による古い文字列書式設定において、桁数の部分を「*」で表現し、桁数を引数で渡す方法があります。この方法は、localeモジュールのlocale.format()やlocale.forma_string()でも同様ですので、サンプル...
Python
Python♪基本：if文の「if…else」「if…elif…else」を使おう
if文は「もしも～だったら」という条件分岐を指定する命令文です。単純なif文については勉強しましたが、ここでは、「if…else」「if…elif…else」の使い方も覚えましょう。これだけ覚えれば、これらを組み合わせて、どんな条件分岐の...
Python
Python♪基本：簡単なfor文とrandom関数を使ってグラフを表示しよう
if文もfor文も配列も関数も知らない状況で、なにからPythonを説明するのがいいのでしょう。スマホを使いこなす世代の子供たちにhello Wolrdの出力が面白いのは最初の１度きりです。プログラミングの家庭教師って、思ったよりも難しい...
Python
Python♪「参照渡し」「浅いコピー」「深いコピー」まずは理屈抜きで覚えよう。
　「参照渡し」「浅いコピー」「深いコピー」がどんな結果になるかを、まずは理屈抜きで覚えましょう。数値型、タプル型、文字列、リスト、ディクショナリ、セットがどんな風になるのかを具体的に細かく説明した記事は、なかなか見つけられませんでしたので、...
Python
Python♪NumPyの「参照渡し」と「コピー」を覚えよう。リストとは全然違う。
　リストの「参照渡し」「浅いコピー」「深いコピー」とNumPyの配列の「参照渡し」「コピー」とは、コンピューターの内部でのメモリーの扱いも実行のしかたも全然違います。これを混同してしまうと大変なことになります。ここでは、NumPyの配列の...
Python
Python♪基本：Pythonは変数や引数の宣言が不要。C言語、VBAとの比較
　Pythonのコードをコード01、C言語のコードをコード02、ExcelのVBAのコードをコード03に示します。それぞれの言語の特徴が出ていると思います。こうして比べてみると確かにPythonってコードが短いですね。でも、感激するほど短く...
Python♪ディレクトリ、カレントディレクトリ、絶対パス、相対パス
Python♪format()メソッドの基本的な使い方
ホーム
Python
最近の投稿

    Python♪用語集：意外に難しいコンテナ、シーケンスなどの分類
    Python♪FEM:行列の積や転置行列のコード記述のコツ
    Python♪FEM：平面トラスの有限要素法サンプルコード
    Python♪FEM:微小変形の仮定と人の感覚の違い
    Python♪２ヶ月ぐらい更新ができなかったので雑談です

Snow Tree in June

    ホーム
    Python♪の学習とホームページ作成のブログ

© 2018 Snow Tree in June.

    メニュー
        ホーム
        Python♪の学習とホームページ作成のブログ
    ホーム
    検索

トップ
サイドバー

    カテゴリー
        HTML3
        Python60
            Pythonチュートリアル2
            Python用語集6
            ゆうちゃんとPython18
            数値解析3
        WordPress3
        ブログ開設8
        雑記2
    新着記事
    Python♪用語集：意外に難しいコンテナ、シーケンスなどの分類
    Python♪FEM:行列の積や転置行列のコード記述のコツ
    Python♪FEM：平面トラスの有限要素法サンプルコード
    Python♪FEM:微小変形の仮定と人の感覚の違い
    Python♪２ヶ月ぐらい更新ができなかったので雑談です



# インポート(ローカルフォルダ以下の所から)

## モジュール

```python
"① import <dir>.<dir>….<module>"

import package.sub_package.package_module1

"呼び出し"
package.sub_package.package_module1.func1()  # -> package_module.func1
package.sub_package.package_module1.func1()  # -> package_module.func1

del package.sub_package.package_module1

"② from <dir>.<dir>… import <module> (複数選択可能)"

from package.sub_package import package_module1, package_module2

"呼び出し"
package_module1.func1()  # -> package_module.func1
package_module2.func1()  # -> package_module2.func1
```

## パッケージ内の指定モジュールを全て

> フォルダ内に`__init__.py`があり、その中に書いた`__all__`変数に
  読み込むモジュールの指定がされている場合のみ

```python
"from <dir>.<dir>….<module> import *"

from package.multiple_import import *

"呼び出し"
included_module.func()
# --all-- で指定しないものはエラーになる

try:
    excluded_module.excluded()
except NameError as e:
    print(e)  # -> name 'excluded_module' is not defined
```

## モジュール内のオブジェクト

```python
"from <dir>.<dir>….<module> import <object> (複数選択可能)"

from package.sub_package.package_module1 import func1, func2

"呼び出し"
func1()  # -> package_module.func1
func2()  # -> package_module.func2
```

## モジュール内のオブジェクトを全て

```python
"from <dir>.<dir>….<module> import *"

from package.sub_package.package_module1 import *

"呼び出し"
func1()  # -> package_module.func1
func2()  # -> package_module.func2
```

# 別名を付けてインポート

## モジュールに別名を付ける

```python
import math as m

print(m.pi)  # -> 3.141592653589793

try:
    print(math.pi)
except NameError as e:
    print(e)  # -> name 'math' is not defined
```

## オブジェクトに別名を付ける

```python
from math import pi as PI

print(PI)  # -> 3.141592653589793

try:
    print(pi)
except NameError as e:
    print(e)  # -> name 'pi' is not defined
```

# PEP8で推奨されている「import」の書き方

> なお、あくまでもスタイルガイドなので
  このように書かないとエラーになるというわけではない。

## 複数モジュールのインポート

> 仕様では`import文`のあとに
  複数のモジュールをカンマで区切って書くことができるが、
  PEP8では推奨されていない。
  一行ずつ分けて書く。

> 非推奨の書き方
```python
import os, sys

print(os, sys)
```

> 推奨の書き方
```python
import os
import sys

print(os, sys)
```

> 次に説明するように`from`を使って
  オブジェクト(関数や変数、クラス)をインポートする場合は
  カンマで区切ってもOK。

```python
from math import pi, radians

print(pi, radians)
```

## モジュールをインポートする順番

> モジュールの種類によって以下の順番でグループ分けして
  インポートするのが推奨されている。
    1. 標準ライブラリ
    2. サードパーティライブラリ
    3. ローカルライブラリ(自作のライブラリ)
> グループ間は空白行で区切る。
> PEP8には書かれていないが、
  グループ内の順番はアルファベット順に並べられることが多い。

```python
"標準モジュール"
import math
import os
import sys

"サードパーティライブラリ"
import pywin

"ローカルライブラリ"
import module1
import module2

print(math, os, sys, pywin, module1, module2)
```

# サードパーティーライブラリからインポート

> パッケージからモジュールやオブジェクトをインポートする場合、
  その構成や`__init__.py`の記述によってインポートの方法に注意が必要。
> なお、基本的にはドキュメントにどのようにインポートすればいいか
  書いてあるので、`__init__.py`を読む必要はない。
  色々なパターンがあるという説明のためいくつか紹介する。

## 「urllib」の例

> 標準ライブラリの「urllib」を例として、
  パッケージからモジュールやオブジェクトをインポートする。

> urllibディレクトリに以下のようにファイル(モジュール)が格納されている。__init__.pyは空。

> urllib/
  ├── __init__.py
  ├── error.py
  ├── parse.py
  ├── request.py
  ├── response.py
  └── robotparser.py

> `import urllib`とした場合、配下のモジュールを使うことはできない。
  例えばurllib.errorとするとエラー`AttributeError`となる。

```python
import urllib

print(type(urllib))  # -> <class 'module'>
print(urllib)
# -> <module 'urllib' from '/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python3.7/urllib/__init__.py'>

try:
    print(urllib.error)
except AttributeError as e:
    print(e)  # -> module 'urllib' has no attribute 'error'
```

> `<パッケージ名>.<モジュール名>`でモジュールをインポートする必要がある。

```python
import urllib.error

print(urllib.error)
# -> <module 'urllib.error' from '/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python3.7/urllib/error.py'>
print(urllib.error.HTTPError)  # -> <class 'urllib.error.HTTPError'>
```

> `from <パッケージ名> import <モジュール名>`でもOK。

```python
from urllib import error

print(error)
# <module 'urllib.error' from '/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python3.7/urllib/error.py'>
print(error.HTTPError)
# <class 'urllib.error.HTTPError'>
```

> オブジェクトを指定してインポートすることも可能。

```python
from urllib.error import HTTPError

print(HTTPError)  # -> <class 'urllib.error.HTTPError'>
```

> このように、`__init__.py`で特に初期化コードが記述されていない場合は、
  パッケージをインポートするのではなく
  配下のモジュールをインポートする必要があるので注意。

> なお、IPython, Jupyter Notebookを使っている場合、
  `urllib`をインポートしただけで`urllib.parse`も使えるようになるが、
  これはIPythonの起動時の処理に起因する挙動。

## 「collections」の例

> 異なる例としてcollectionsを挙げる。

> `collections`ディレクトリは以下のような構成になっている。

> collections/
  ├── __init__.py
  └── abc.py

> `collections`では`urllib`のように
  配下にモジュールのファイルが格納されているのではなく、
  __init__.pyでクラスなどが定義されている。
> `Counter`や`OrderedDict`などはモジュールではなくクラス。

> このような場合、パッケージをインポートした上で
  `<パッケージ名>.<クラス名>`としてクラスを使用できる。

```python
import collections

print(collections)
# -> <module 'collections' from '/usr/local/Cellar/python/3.7.0/Frameworks/Python.framework/Versions/3.7/lib/python3.7/collections/__init__.py'>
print(collections.Counter)  # -> <class 'collections.Counter'>
```

> `<パッケージ名>.<クラス名>`としてクラスをインポートすることはできない。

```python
try:
    import collections.Counter
except ModuleNotFoundError as e:
    print(e)  # -> No module named 'collections.Counter'
```

> `from`を使ってクラスをインポートするのはOK。

```python
from collections import Counter

print(Counter)  # -> <class 'collections.Counter'>
```

## 「NumPy」の例

> サードパーティライブラリとしてNumPyを例とする。

> NumPyではnumpyディレクトリの`__init__.py`の中で
  各サブパッケージをインポートしている。

> このため、それぞれのモジュールをインポートする必要はなく、
  `import numpy as np`とするだけで各種の関数などが使える。

## 「scikit-learn」の例

> `scikit-learn`では`sklearn`ディレクトリの`__init__.py`では
  サブパッケージをインポートしていない。
> このため、サブパッケージを明示的にインポートする必要がある。

[](https://note.nkmk.me/python-import-usage/)
[](https://snowtree-injune.com/2018/09/04/package1/)
