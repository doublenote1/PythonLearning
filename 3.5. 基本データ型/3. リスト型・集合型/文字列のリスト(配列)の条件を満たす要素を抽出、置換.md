> 文字列を要素とするリスト(配列)から、
  特定の条件を満たす文字列の要素のみを抽出したり、
  置換や変換などの処理をしたりして新たなリストを生成する。
> リスト内包表記を使う。

> 文字列の抽出や置換についての詳細は以下の記事を参照。
[](https://note.nkmk.me/python-str-extract/)
[](https://note.nkmk.me/python-str-replace-translate-re-sub/)

> なお、リストは異なる型のデータを格納可能で、厳密には配列とは異なる。
  メモリサイズやメモリアドレスを必要とするような処理や
  大規模なデータの数値計算処理などで配列を扱いたい場合は
  `array`(標準ライブラリ)や`NumPy`を使う。
[](https://note.nkmk.me/python-list-array-numpy-ndarray/)

# リスト内包表記

> リストから新たなリストを生成する場合はリスト内包表記を使うと
  `for`ループよりもシンプルに書ける。
  `[式 for 任意の変数名 in イテラブルオブジェクト if 条件式]`
[](../../5.%20特殊構文/内包表記.md)

> 要素を条件式で選択するだけであれば式で処理することはないので、
  `[変数名 for 変数名 in 元のリスト if 条件式]`
  という形になる。

> if 条件式をif not 条件式にすると否定になり、
  条件式を満たさない要素を抽出できる。

> リスト内包表記を使ったリストの要素の抽出や置換・変換などについての詳細は
  以下の記事を参照。
[](文字列のリスト(配列)の条件を満たす要素を抽出、置換.md)

# 特定の文字列を含む(部分一致) / 含まない: in

> `<特定の文字列> in <元の文字列>`で、
  元の文字列に特定の文字列が含まれるとTrueを返す。
  これを条件式とする。

> `in`の否定は`not in`を使う。
[](リストなどに特定の要素が含まれるか判定.md)

```python
lst = ['oneXXXaaa', 'twoXXXbbb', 'three999aaa', '000111222']

lst_in = [s for s in lst if 'XXX' in s]
print(lst_in)  # -> ['oneXXXaaa', 'twoXXXbbb']

lst_in_not = [s for s in lst if 'XXX' not in s]
print(lst_in_not)  # -> ['three999aaa', '000111222']
```

# 特定の文字列を置換

> リストの要素の文字列を置換したい場合、
  リスト内包表記で各要素に文字列メソッド`replace()`を使う。

> 置換対象の文字列がない場合は`replace()`を適用しても変更しないので、
  `if` 条件式で要素を選択する必要はない。

```python
lst = ['oneXXXaaa', 'twoXXXbbb', 'three999aaa', '000111222']

lst_replace = [s.replace('XXX', 'ZZZ') for s in lst]
print(lst_replace)
# -> ['oneZZZaaa', 'twoZZZbbb', 'three999aaa', '000111222']
```

> 特定の文字列を含む要素をまるごと置き換えたい場合は
  `in`で抽出して三項演算子で処理する。

> リスト内包表記の式の部分を三項演算子とすればOK。

[](リスト(配列)の特定の要素を抽出、置換、変換.md)
```python
lst = ['oneXXXaaa', 'twoXXXbbb', 'three999aaa', '000111222']

lst_replace_all = ['ZZZ' if 'XXX' in s else s for s in lst]
print(lst_replace_all)  # -> ['ZZZ', 'ZZZ', 'three999aaa', '000111222']

"""まとまりごとに括弧で囲むと以下のようになる。
慣れないうちは括弧を使ったほうが理解しやすく間違いがないかもしれない。
文法上は括弧を書いても問題はない"""

x = [('ZZZ' if ('XXX' in s) else s) for s in lst]
```

> 条件としてinを使うとリスト内包表記のinと紛らわしいが、
  リスト内包表記および三項演算子の構文の形を意識すれば難しくない。

# 特定の文字列で始まる / 始まらない: startswith()

> 文字列メソッド`startswith()`は、
  文字列が引数に指定した文字列で始まると`True`を返す。

`bool型 = str.startswith(prefix[, start[, end]])`

```python
lst = ['oneXXXaaa', 'twoXXXbbb', 'three999aaa', '000111222']

lst_start = [s for s in lst if s.startswith('t')]
print(lst_start)  # -> ['twoXXXbbb', 'three999aaa']
lst_start_not = [s for s in lst if not s.startswith('t')]
print(lst_start_not)  # -> ['oneXXXaaa', '000111222']
```

# 特定の文字列で終わる / 終わらない: endswith()

> 文字列メソッド`endswith()`は、
  文字列が引数に指定した文字列で終わると`True`を返す。

`bool型 = str.endswith(prefix[, start[, end]])`

```python
lst = ['oneXXXaaa', 'twoXXXbbb', 'three999aaa', '000111222']

lst_end = [s for s in lst if s.endswith('aaa')]
print(lst_end)  # -> ['oneXXXaaa', 'three999aaa']
lst_end_not = [s for s in lst if not s.endswith('aaa')]
print(lst_end_not)  # -> ['twoXXXbbb', '000111222']
```

# 大文字・小文字で判定し抽出

> 文字列メソッド`isupper()`, `islower()`で
  文字列がすべて大文字か小文字かを判定できる。

> メソッドの詳細は以下の記事を参照。
[](https://note.nkmk.me/python-capitalize-lower-upper-title/)

```python
lst = ['oneXXXaaa', 'twoXXXbbb', 'three999aaa', '000111222']

lst_lower = [s for s in lst if s.islower()]
print(lst_lower)  # -> ['three999aaa']
```

# 大文字・小文字を変換

> すべての文字を大文字や小文字に変換したい場合は、
  文字列メソッド`upper()`や`lower()`を使う。
  そのほか、最初の一文字だけ大文字にする`capitalize()`や、
  大文字と小文字を入れ替える`swapcase()`などもある。

> メソッドの詳細は以下の記事を参照。
[](https://note.nkmk.me/python-capitalize-lower-upper-title/)

> 上述の置換の例と同様に、条件を満たす要素のみ処理したい場合は
  三項演算子を使う。

```python
lst = ['oneXXXaaa', 'twoXXXbbb', 'three999aaa', '000111222']

lst_upper_all = [s.upper() for s in lst]
print(lst_upper_all)
# -> ['ONEXXXAAA', 'TWOXXXBBB', 'THREE999AAA', '000111222']

lst_lower_to_upper = [s.upper() if s.islower() else s for s in lst]
print(lst_lower_to_upper)
# -> ['oneXXXaaa', 'twoXXXbbb', 'THREE999AAA', '000111222']
```

# 英字か数字か判定し抽出

> 文字列メソッド`isalpha()`や`isnumeric()`で、
  文字列がすべて英字か数字かなどを判定できる。

> 詳細は以下の記事を参照。
[](https://note.nkmk.me/python-str-num-determine/)

```python
lst = ['oneXXXaaa', 'twoXXXbbb', 'three999aaa', '000111222']

lst_isalpha = [s for s in lst if s.isalpha()]
print(lst_isalpha)  # -> ['oneXXXaaa', 'twoXXXbbb']
lst_isnumeric = [s for s in lst if s.isnumeric()]
print(lst_isnumeric)  # -> ['000111222']
```

# 複数条件

> リスト内包表記の条件式の部分は複数条件にすることもできる。
  複数の条件式をandやorでつなげればOK。否定notも使える。
> 三つ以上の条件式を使う場合は順番によって結果が異なるので、
  まとまりごとに()で囲んでおいたほうが無難。

```python
lst = ['oneXXXaaa', 'twoXXXbbb', 'three999aaa', '000111222']

lst_multi = [s for s in lst if s.isalpha() and not s.startswith('t')]
print(lst_multi)  # -> ['oneXXXaaa']

lst_multi_or = [s for s in lst if (s.isalpha() and not s.startswith('t')) or ('bbb' in s)]
print(lst_multi_or)  # -> ['oneXXXaaa', 'twoXXXbbb']
```

# 正規表現

> 正規表現を使うと自由度の高い処理が可能。
[](https://note.nkmk.me/python-re-match-search-findall-etc/)

> `re.match()`がマッチしたときに返す`match`オブジェクトを
  条件式で評価すると常にTrueと判定される。
> マッチしない場合は条件式で`False`となる`None`を返すので、
  正規表現にマッチする要素のみを抽出する場合は、
  これまでのようにリスト内包表記の条件式の部分に`re.match()`を適用すればOK。

```python
import re

lst = ['oneXXXaaa', 'twoXXXbbb', 'three999aaa', '000111222']

lst_re_match = [s for s in lst if re.match('.*XXX.*', s)]
print(lst_re_match)  # -> ['oneXXXaaa', 'twoXXXbbb']

"""正規表現にマッチした部分を置換するre.sub()も便利。
マッチした要素のみを抽出して置換する場合はif 条件式を追加すればOK"""

lst_re_sub_all = [re.sub('(.*)XXX(.*)', r'\2---\1', s) for s in lst]
print(lst_re_sub_all)
# ['aaa---one', 'bbb---two', 'three999aaa', '000111222']

lst_re_sub = [re.sub('(.*)XXX(.*)', r'\2---\1', s)
              for s in lst if re.match('.*XXX.*', s)]
print(lst_re_sub)  # -> ['aaa---one', 'bbb---two']
```

# リンク

[](https://note.nkmk.me/python-list-str-select-replace/)
