# 要素の取得・変更

## 要素の取得

### 単一要素の取得

#### リスト・タプル

```python
lst = [0, 1, 2, 3, 4, 5]

"""
 リスト「lst」のインデックス
 +---+---+---+---+---+---+
 | 0 | 1 | 2 | 3 | 4 | 5 |
 +---+---+---+---+---+---+
 0   1   2   3   4   5   6
-6  -5  -4  -3  -2  -1
"""

"要素を取得"
print(lst[0])  # -> 0
print(lst[-1])  # -> 5

"インデックス範囲外はエラー"
try:
    print(lst[10])
except IndexError as e:
    print(e)  # -> list index out of range
```

#### 文字列

```python
word = 'Python'

"""
 文字列'Python'のインデックス
 +---+---+---+---+---+---+
 | P | y | t | h | o | n |
 +---+---+---+---+---+---+
 0   1   2   3   4   5   6
-6  -5  -4  -3  -2  -1
"""

print(word[0])  # -> P
print(word[-1])  # -> n

"インデックス範囲外はエラー"
try:
    print(word[10])
except IndexError as e:
    print(e)  # -> list index out of range
```

### 複数要素の取得

#### スライス構文を使用

`<抽出されたシーケンス型> = シーケンス型[start:stop:step]`

> `a[i:j]`とした時、`i`番目から`j-1`番目の要素を取り出す
> ただし、0 <= `i` < `j` の関係を満たす
> また、【`i` < 0 のとき `i` = `len(a)` + `i`】
   `j` < 0 のとき `j` = `len(a)` + `j`】とする）

```python
"リスト"
lst = [0, 1, 2, 3, 4, 5]
print(lst[0:2], lst[2:6])  # -> [0, 1] [2, 3, 4, 5]
print(lst[-6:-4], lst[-4:6])  # -> [0, 1] [2, 3, 4, 5]
print(lst[0:-1:2])  # -> [0, 2, 4]

"文字列"
word = 'Python'
print(word[0:2], word[2:6])  # -> Py thon
print(word[-6:-4], word[-4:6])  # -> Py thon
print(word[0:-1:2])  # -> Pto

"要素数を超える位置を指定してもエラーにはならず無視される"
print(lst[1:10])  # -> [1, 2, 3, 4, 5]

"どの要素も選択されないと「空」のシーケンスが返る"
print(lst[4:2])  # -> []
print(lst[2:2])  # -> []
print(lst[10:20])  # -> []

"""開始インデックスを省略した場合は最初から、
終了インデックスを省略した場合は最後までが選択される"""
print(lst[:0], lst[0:])  # -> [] [0, 1, 2, 3, 4, 5]
print(lst[:3], lst[3:])  # -> [0, 1, 2] [3, 4, 5]
print(lst[:6], lst[6:])  # -> [0, 1, 2, 3, 4, 5] []
"全体のコピー"
print(lst[:])  # -> [0, 1, 2, 3, 4, 5]

"""「ステップ数」を負の値で指定すると、後ろから逆順で要素を取得。
開始インデックスから逆向きに値を取得していくため、
開始インデックスのほうが終了インデックスより後ろの位置を示していないと
空になってしまう"""
print(lst[5:2:-1])  # -> [5, 4, 3]
print(lst[2:5:-1])  # -> []
print(lst[::-1])  # -> [5, 4, 3, 2, 1, 0]
```

#### slice関数を使用

`スライス型 = slice(start, stop[, step])`
`スライス型 = slice(stop)`

> 組み込み関数`slice()`を使うと「スライスオブジェクト」を生成できる
> 同じ位置の要素を繰り返し取得したい場合は
  「スライスオブジェクト」を一度生成しておくだけでよいので便利

```python
lst = [0, 1, 2, 3, 4, 5]

"引数に start, stop, step (start:stop:step と等価)"
sl = slice(1, 5, 2)
print(sl)  # -> slice(1, 5, 2)
print(type(sl))  # -> <class 'slice'>
print(lst[sl])  # -> [1, 3]

"引数に start, stop (start:stop と等価)"
sl = slice(1, 5)
print(sl)  # -> slice(1, 5, None)
print(lst[sl])  # -> [1, 2, 3, 4]

"引数に stop (:stop と等価)"
sl = slice(2)
print(sl)  # -> slice(None, 2, None)
print(lst[sl])  # -> [0, 1]

"引数を全て省略するとエラー"
try:
    sl = slice()
except TypeError as e:
    print(e)  # -> slice expected at least 1 arguments, got 0

"""全体を表すスライス:を「slice()」関数で生成したい場合は
明示的に「None」を指定"""
sl = slice(None)
print(sl)  # -> slice(None, None, None)
print(lst[sl])  # -> [0, 1, 2, 3, 4, 5]
```

## 要素の変更

### 文字列の要素は変更不可

> 文字列要素は 追加・変更・削除不可(immutable)

```python
word = 'Python'
try:
    word[0] = 'J'
except TypeError as e:
    print(e)  # -> 'str' object does not support item assignment

print('J' + word[1:])  # -> Jython
```

### その他シーケンス型

#### スライスへ代入せず要素を変更

* 要素の追加

`list型 = list型.append(リスト末尾に追加する要素)`
`list型 += リスト末尾に追加する「リスト」`

```python
lst = [0, 1, 2]
lst.append(3)
print(lst)  # -> [0, 1, 2, 3]
lst += [4]
print(lst)  # -> [0, 1, 2, 3, 4]
lst += [5, 6]
print(lst)  # -> [0, 1, 2, 3, 4, 5, 6]
```

* 要素の変更

```python
lst = [0, 1, 2]
lst[0] = 100
print(lst)  # -> [100, 1, 2]
```

* 要素の削除

```python
lst = list(range(9))

"単一要素の削除"
del lst[0]
print(lst)  # -> [1, 2, 3, 4, 5, 6, 7, 8]
del lst[-1]
print(lst)  # -> [1, 2, 3, 4, 5, 6, 7]

"複数要素の削除"
del lst[3:5]
print(lst)  # -> [1, 2, 3, 6, 7]
del lst[::2]
print(lst)  # -> [2, 6]
del lst[:]
print(lst)  # -> []
```

#### スライスへ代入し要素を変更

```python
lst = ['a', 'b', 'c', 'd', 'e', 'f', 'g']

"範囲上書き"
lst[2:5] = ['C', 'D', 'E']
print(lst)  # -> ['a', 'b', 'C', 'D', 'E', 'f', 'g']

"範囲削除"
lst[2:5] = []
print(lst)  # -> ['a', 'b', 'f', 'g']

"空の範囲(位置)に挿入"
lst[0:0] = ['Top']
lst[100:100] = ['Bottom']
print(lst)  # -> ['Top', 'a', 'b', 'f', 'g', 'Bottom']

"全体を上書き"
lst[:] = [1, 2, 3]
print(lst)  # -> [1, 2, 3]

"すべて削除"
lst[:] = []
print(lst)  # -> []

"""増分stepを指定した飛び飛びの範囲に対しては
要素数が等しくないとエラーValueErrorとなる"""
lst = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
print(lst[1::2])  # -> [1, 3, 5, 7, 9]
lst[1::2] = [10, 30, 50, 70, 90]
print(lst)  # -> [0, 10, 2, 30, 4, 50, 6, 70, 8, 90]

print(lst[::2])  # -> [0, 2, 4, 6, 8]
try:
    lst[::2] = [100, 200]
except ValueError as e:
    print(e)  # -> attempt to assign sequence of size 2 to extended slice of size 5

"""右辺にはイテラブルのみ指定できる
スカラー値を指定するとエラー"""
try:
    lst[2:3] = 200
except TypeError as e:
    print(e)  # -> can only assign an iterable
```

# 二次元配列にスライスを適用

> リストのリストで構成された以下のような二次元配列に
  スライスを適用したい場合。

[1](../../5.%20特殊構文/内包表記.md)
[2](7.%20リスト型の二次元配列の行と列の入替(転置).md)
```python
lst_2d = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]]

"""あくまでもリストを要素としたリストなので、
スライスによって選択されるのは要素であるリスト"""

print(lst_2d[1:3])  # -> [[3, 4, 5], [6, 7, 8]]

"選択されたリストにさらにスライスを適用するにはリスト内包表記を使う[1]"

print([l[:2] for l in lst_2d[1:3]])  # -> [[3, 4], [6, 7]]

"列を取得したい場合は転置する方法もある[2]"

lst_2d_t = [list(x) for x in zip(*lst_2d)]
print(lst_2d_t)
# [[0, 3, 6, 9], [1, 4, 7, 10], [2, 5, 8, 11]]
print(lst_2d_t[1])
# [1, 4, 7, 10]
```

> なお、配列のサイズや実現したいことにもよるが、
  NumPyをインストールできる環境であれば多次元配列の操作はNumPyを
  使うほうが楽。

> NumPyではarr`[1:4, 2:5]`のように各次元のスライスをカンマで区切って
  指定できる。
[](https://note.nkmk.me/python-numpy-ndarray-slice/)

# 変数に代入した場合の浅いコピーと深いコピー

> スライスで取得した結果は浅いコピーとなる。
> 例えば、数値のリストの場合などは、
  スライスで取得した結果を変数に代入しその変数の要素を更新しても
  元のオブジェクトは変更されない。

```python
lst = [0, 10, 20, 30, 40, 50, 60]

lst_slice = lst[2:5]
print(lst_slice)  # -> [20, 30, 40]
lst_slice[1] = 300
print(lst_slice)  # -> [20, 300, 40]
print(lst)  # -> [0, 10, 20, 30, 40, 50, 60]
```

> 要素としてリストなどを含んでいる複合オブジェクトの場合は、
  リストの要素を更新すると元のオブジェクトも変更される。

```python
lst_2d = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]]

lst_2d_slice = lst_2d[1:3]
print(lst_2d_slice)  # -> [[3, 4, 5], [6, 7, 8]]
lst_2d_slice[0][1] = 400
print(lst_2d_slice)  # -> [[3, 400, 5], [6, 7, 8]]
print(lst_2d)  # -> [[0, 1, 2], [3, 400, 5], [6, 7, 8], [9, 10, 11]]
```

> これを防ぐためには標準ライブラリのcopyモジュールをインポートし、deepcopy()を使う。
[](../../3.%20基本構文/3.%20コピー.md)

```python
import copy

lst_2d = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]]

l_2d_slice_deepcopy = copy.deepcopy(lst_2d[1:3])
print(l_2d_slice_deepcopy)  # -> [[3, 4, 5], [6, 7, 8]]
l_2d_slice_deepcopy[0][1] = 400
print(l_2d_slice_deepcopy)  # -> [[3, 400, 5], [6, 7, 8]]
print(lst_2d)  # -> [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]]
```

# 文字列やタプルの場合

> これまではリストの例を示してきたが、
  文字列やタプルなどほかのシーケンスオブジェクトでも同様に
  スライスが使える。
> ただし、文字列、タプルはイミュータブル(更新不可)なので代入はできない。

```python
s = 'abcdefg'

print(s[2:5])  # -> cde
print(s[::-1])  # -> gfedcba
try:
    s[2:5] = 'CDE'
except TypeError as e:
    print(e)  # -> 'str' object does not support item assignment

tpl = (0, 10, 20, 30, 40, 50, 60)

print(tpl[2:5])  # -> (20, 30, 40)
try:
    tpl[2:5] = (200, 300, 400)
except TypeError as e:
    print(e)  # -> 'tuple' object does not support item assignment
```

# 入れ子のリスト

```python
"リストの作成"
s = ['a', 'b', 'c']
n = [1, 2, 3]
nest = [s, n, 'string', 100]

"リストの参照"
print(nest)  # -> [['a', 'b', 'c'], [1, 2, 3], 'string', 100]
print(nest[0])  # -> ['a', 'b', 'c']
print(nest[0][1])  # -> b
print(nest[2])  # -> string
```

# リンク

[](https://note.nkmk.me/python-slice-usage/)
