# 増加

## 要素を追加

`None = list型.append(object)`

```python
lst = list(range(3))
print(lst)  # -> [0, 1, 2]
lst.append('appended')
print(lst)  # -> [0, 1, 2, 'appended']
lst.append([0, 1])
print(lst)  # -> [0, 1, 2, 'appended', [0, 1]]
```

`None = set型.add(イミュータブル)`

```python
st = set(range(3))
print(st)  # -> {0, 1, 2}
st.add('added')
print(st)  # -> {0, 1, 2, 'added'}
st.add((0, 1))
print(st)  # -> {0, 1, 2, (0, 1), 'added'}
try:
    st.add([0])
except TypeError as e:
    print(e)  # -> unhashable type: 'list'
```

## 要素を挿入

`None = list型.insert(index, object)`

```python
lst = list(range(3))
print(lst)  # -> [0, 1, 2]
lst.insert(0, 'inserted')
print(lst)  # -> ['inserted', 0, 1, 2]
lst.insert(-1, [0, 1])
print(lst)  # -> ['inserted', 0, 1, [0, 1], 2]
```

## イテラブルを結合

`None = list型.extend(イテラブル)`
> 処理速い

`None = list型 += イテラブル`
> 処理遅い

```python
lst = list(range(2))
print(lst)  # -> [0, 1]
lst.extend([2, 3])
print(lst)  # -> [0, 1, 2, 3]
lst.extend((4, 5))
print(lst)  # -> [0, 1, 2, 3, 4, 5]
lst.extend({6, 7})
print(lst)  # -> [0, 1, 2, 3, 4, 5, 6, 7]
lst.extend({8: 'a', 9: 'b'})
print(lst)  # -> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
lst.extend(range(10, 12))
print(lst)  # -> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
lst.extend('AB')
print(lst)  # -> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 'A', 'B']
```

# 削除

## 指定した値と同じの、最初の要素を削除

`None = (list型|set型).remove(x)`
> 存在しない値を指定するとエラー発生

```python
"リスト"
lst = list(range(3))
print(lst)  # -> [0, 1, 2]
lst.remove(2)
print(lst)  # -> [0, 1]
try:
    lst.remove(2)
except ValueError as e:
    print(e)  # -> list.remove(x): x not in list
print()

"セット"
st = set(range(3))
print(st)  # -> {0, 1, 2}
st.remove(2)
print(st)  # -> {0, 1}
try:
    st.remove(5)
except KeyError as e:
    print(e)  # -> 5
print()

"指定した値と同じ要素を全て削除したい時"
lst = [0, 1, 0, 2, 3, 0]
while lst.count(0):
    lst.remove(0)
print(lst)  # -> [1, 2, 3]
```

`None = set型.discard(x)`
> 存在しない値を指定すると何もしない

```python
st = set(range(3))
print(st)  # -> {0, 1, 2}
st.discard(2)
print(st)  # -> {0, 1}
st.discard(2)
print(st)  # -> {0, 1}
```

## 要素を取得して削除

`抽出された要素 = list型.pop([index])`

```python
lst = list(range(5))
print(lst)  # -> [0, 1, 2, 3, 4]
print(lst.pop())  # -> 4
print(lst)  # -> [0, 1, 2, 3]
print(lst.pop(0))  # -> 0
print(lst)  # -> [1, 2, 3]
print(lst.pop(-1))  # -> 3
print(lst)  # -> [1, 2]
try:
    print(lst.pop(3))
except IndexError as e:
    print(e)  # -> pop index out of range
```

`抽出された要素 = set型.pop()`
> 要素はランダム抽出される
> set型からはインデックスを指定できない

```python
st = set(range(2))
print(st)  # -> {0, 1}
print(st.pop())  # -> 0
print(st)  # -> {1}
print(st.pop())  # -> 1
print(st)  # -> set()
try:
    print(st.pop())
except KeyError as e:
    print(e)  # -> 'pop from an empty set'
```

## 全ての要素を削除

`None = (list型|set型).clear()`

```python
"リスト"
lst = list(range(3))
print(lst)  # -> [0, 1, 2]
lst.clear()
print(lst)  # -> []

"セット"
st = set(range(3))
print(st)  # -> {0, 1, 2}
st.clear()
print(st)  # -> set()
```

# 並び替え

## 昇順・降順で並び替えしたリストを取得

`list型 = sorted(iterable,*,key=None,reverse=False)`
> `key` `reverse`はキーワード引数として指定必須

```python
"イテラブルをリストに変換しソート"
print(sorted([3, 2, 1]))  # -> [1, 2, 3]
print(sorted((3, 2, 1)))  # -> [1, 2, 3]
print(sorted({3, 2, 1}))  # -> [1, 2, 3]
print(sorted({3:'c', 2:'b', 1:'a'}))  # -> [1, 2, 3]
print(sorted({3:'c', 2:'b', 1:'a'}.values()))  # -> ['a', 'b', 'c']
print(sorted({3:'c', 2:'b', 1:'a'}.items()))
# -> [(1, 'a'), (2, 'b'), (3, 'c')]
print(sorted('321'))  # -> ['1', '2', '3']

"引数を省略すると「昇順」"
lst_al = ['c', 'bc', 'abc', 'C', 'BC', 'ABC']
lst_nihongo = [
      '参', '弐', '壱'
    , 'ウ', 'イウ', 'アイウ'
    , 'う', 'いう', 'あいう'
]
lst_num = [123, 23, 3, 0, 0.0, -1, 1, 1.5, -1.5]
lst_snum = ['123', '23', '3', '0', '0.0', '-1', '1', '1.5', '-1.5']
print(sorted(lst_al))
# ->  ['ABC', 'BC', 'C', 'abc', 'bc', 'c']
print(sorted(lst_nihongo))
# ->  ['あいう', 'いう', 'う', 'アイウ', 'イウ', 'ウ', '参', '壱', '弐']
print(sorted(lst_num))
# ->  [-1.5, -1, 0, 0.0, 1, 1.5, 3, 23, 123]
print(sorted(lst_snum))
# ->  ['-1', '-1.5', '0', '0.0', '1', '1.5', '123', '23', '3']

"降順でソート"
print(sorted([1, 2, 3], reverse=True))  # -> [3, 2, 1]

"数値と文字列はソート方法が違う為、一緒にソートできない"
lst_comp = ['123', '23', '3', 123, 23, 3]
try:
    print(sorted(lst_comp))
except TypeError as e:
    print(e)  # -> '<' not supported between instances of 'int' and 'str'

"===並び替え方法指定==="

"文字数で並び替え"
lst = ["Alice", "Bob", "Carl"]
print(sorted(lst, key=len))  # -> ['Bob', 'Carl', 'Alice']

"大文字小文字区別なく並び替え"
lst = ['c', 'bc', 'abc', 'C', 'BC', 'ABC']
print(sorted(lst, key=str.lower))
# -> ['abc', 'ABC', 'bc', 'BC', 'c', 'C']
```

## 昇順・降順で並び替え

`None = list型.sort(key=None,reverse=False)`

```python
lst = [5, 1, 9, 2, 4]

"昇順"
lst.sort()
print(lst)  # -> [1, 2, 4, 5, 9]

"降順"
lst.sort(reverse=True)
print(lst)  # -> [9, 5, 4, 2, 1]


lst_al = ['abc', 'bc', 'c']
lst_num = [123, 23, 3, 0, 0.0, -1, 1, 1.5, -1.5]
lst_snum = ['123', '23', '3', '0', '0.0', '-1', '1', '1.5', '-1.5']
lst_comp = ['123', '23', '3', 123, 23, 3]
word = 'abc'

"昇順"
lst_al.sort()
print(lst_al)  # ->  ['abc', 'bc', 'c']
lst_num.sort()
print(lst_num)  # ->  [-1.5, -1, 0, 0.0, 1, 1.5, 3, 23, 123]
lst_snum.sort()
print(lst_snum)  # ->  ['-1', '-1.5', '0', '0.0', '1', '1.5', '123', '23', '3']
try:
    word.sort()
except AttributeError as e:
    print(e)  # -> 'str' object has no attribute 'sort'
try:
    print(sorted(lst_comp))
except TypeError as e:
    print(e)  # -> '<' not supported between instances of 'int' and 'str'

"降順"
print(sorted(lst_al, reverse=True))  # -> ['c', 'bc', 'abc']


```

## 要素を逆順に取り出すイテレータを取得

`reversed(seq)`

```python
lst = ['abcd', 'za', 'efg', 'abcd', 'za', 'efg']
word = 'strawberry'

print(reversed(lst))  # -> <list_reverseiterator object at 0x0000000003917A90>
print(reversed(word))  # -> <reversed object at 0x0000000003917A90>
```

## 逆順で並び替え

`None = list.reverse()`

```python
lst = [5, 1, 9, 2, 4]
lst.reverse()
print(lst)  # -> [4, 2, 9, 1, 5]
```

## ランダムソート（シャッフル）

`None = random.shuffle(list[, random])`

```python
import random

lst = list(range(5))
random.shuffle(lst)
print(lst)  # -> [2, 4, 1, 0, 3]
```

# インデックスを取得

`sequence.index(x[,start[,end]])`
> 引数の内容を持った要素の位置インデックスを取得

```python
lst = [3, 4, 1, 2, 3, 1, 6, 3, 3]
word = 'strawberry'

print(lst.index(1))  # -> 2
print(lst.index(1, 3))  # -> 5
print(word.index('raw'))  # -> 2
try:
    print(lst.index(1, 3, 4))
except ValueError as e:
    print(e)  # -> 1 is not in list
```

# 要素の数を取得

`len(seq|collection)`
> 全体の要素数

```python
lst = [3, 4, 1, 2, 3, 1, 6, 3, 3]
s = set(lst)
word = 'strawberry'

print(len(lst))  # -> 9
print(len(s))  # -> 5
print(len(word))  # -> 10
```

`sequence.count(x)`
`str.count(x[,start[,end]])`
> 引数の内容を持った要素の数、もしくは引数の文字列の存在数

```python
lst = [3, 4, 1, 2, 3, 1, 6, 3, 3]
word = 'strawberry'

print(lst.count(3))  # -> 4
print(word.count('r'))  # -> 3
print(word.count('berry'))  # -> 1
print(word.count('r', 3))  # -> 2
print(word.count('r', 8, 9))  # -> 1
```

# 要素全体の計算値を取得

`sum(iterable[,start])`
> 要素全体の合計

`any(iterable)`
> リスト要素のいずれかが「True」であれば「True」を返す

`all(iterable)`
> リスト要素すべてが「True」であれば「True」を返す

```python
lst = [1, 2, 3, 4, 5]
lst_1_true = [0, 1, 0, 0, 0]
lst_all_false = [0, 0, 0, 0, 0]

"要素全体の合計"
print(sum(lst))  # -> 15

"要素全体の平均値"
print(sum(lst) / len(lst))  # -> 3.0

print(any(lst))  # -> True
print(any(lst_1_true))  # -> True
print(any(lst_all_false))  # -> False

print(all(lst))  # -> True
print(all(lst_1_true))  # -> False
print(all(lst_all_false))  # -> False
```

# 特定の要素を取得

## 最大・最小要素

`max|min(iterable,*[,key,default])`
`max|min(arg1,arg2,*args[,key])`
> 下記の例はすべて min にも当てはまる

```python
lst = ['abcd', 'za', 'efg', 'abcd', 'za', 'efg']
lst_0 = []

print(max(lst))  # -> za
print(max(lst, key=len))  # -> abcd
try:
    print(max(lst_0))
except ValueError as e:
    print(e)  # -> max() arg is an empty sequence
print(max(lst_0, default='NOTHING!!!'))  # -> NOTHING!!!
print(max('item000', 'item1', 'item01', key=len))  # -> item000
```

## 最大値・最小値から順にn個の要素を取得

`import heapq`
`heapq.nlargest(n, iterable, key=None)`
`heapq.nsmallest(n, iterable, key=None)`

```python
import heapq

lst = ['abcd', 'za', 'efg', 'abcd', 'za', 'efg']
s = set(lst)
word = 'strawberry'

print(heapq.nlargest(3, lst))  # -> ['za', 'za', 'efg']
print(heapq.nlargest(3, s))  # -> ['za', 'efg', 'abcd']
print(heapq.nlargest(3, word))  # -> ['y', 'w', 't']
print(heapq.nsmallest(3, lst))  # -> ['abcd', 'abcd', 'efg']
print(heapq.nsmallest(3, s))  # -> ['abcd', 'efg', 'za']
print(heapq.nsmallest(3, word))  # -> ['a', 'b', 'e']
```

## ランダムに要素を一つ取得

`random.choice(seq)`

`random.seed(a=None, version=2)`
> 乱数シードを固定

```python
import random

random_l = list(range(5))
random_w = 'ABCDE'

print(random.choice(random_l))  # -> 1
print(random.choice(random_w))  # -> A

random.seed(0)
print(random.choice(random_l))  # -> 3
```

## ランダムに複数の要素を取得（重複なし）

`random.sample(population, k)`

```python
import random

random_l = list(range(5))
random_w = 'ABCDE'

print(random.sample(random_l, 3))  # -> [3, 4, 2]
print(random.sample(random_w, 3))  # -> ['E', 'A', 'B']
```

## ランダムに複数の要素を取得（重複あり）

`random.choices(population,weights=None,*,cum_weights=None,k=1)`
> 引数`weights`でそれぞれの要素が選ばれる重み（確率）を指定できる
> `weights`に指定するリストの要素の型は`int`でも`float`でもOK
> 0にするとその要素は選ばれない。

```python
import random

random_l = list(range(5))
print(random.choices(random_l))  # -> [0]
print(random.choices(random_l, k=3))  # -> [3, 0, 3]
print(random.choices(random_l, k=10))  # -> [3, 3, 4, 4, 3, 2, 0, 4, 0, 1]
print(random.choices(random_l, k=3, weights=[1, 1, 1, 10, 1]))  # -> [3, 0, 3]
print(random.choices(random_l, k=3, weights=[1, 1, 0, 0, 0]))  # -> [1, 0, 1]

'''
引数`cum_weights`に累積的な重みとして指定することもできる
以下のサンプルコードの`cum_weights`は上の一つ目の`weights`と等価
'''

print(random.choices(random_l, k=3, cum_weights=[1, 2, 3, 13, 14]))  # -> [3, 1, 2]
```

