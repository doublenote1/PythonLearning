# クラスの役割

コードの再利用を可能にする仕組みの種類:

   * 関数:
        何らかの定型処理を行うひとまとまりのコードを再利用するための仕組み

   * クラス:
        何らかのデータ(インスタンス変数)と、それらを処理するための
        コード(メソッド)をひとまとめにして名前を付けることで、
        を再利用するための仕組み

   * パッケージ、モジュール:
        複数の関数などを1つ以上のファイルにまとめることで、
        それらを他のコードから再利用するための仕組み

# クラスを継承するとは

Pythonでは「全てのオブジェクトの基盤」となる`object`クラスがある。
引数を省略しクラスを定義したときには、
そのクラスは`object`クラスから、全てのクラスのインスタンスに共通な
さまざまな特性を受け継ぐ。
このように、何らかのクラスからその属性を受け継ぐことを、「継承」と呼ぶ。

このとき、継承元となるクラスのことを
「親クラス」「スーパークラス」「基底クラス」などと呼び、
継承先となるクラスのことを
「子クラス」「サブクラス」「派生クラス」などと呼ぶ。
このようなクラス間の継承関係を「継承階層」と呼ぶ。

また、「`object`クラス(親クラス) →(継承)→ `Man`クラス(子クラス)」
のような継承階層がある時、
`Man`クラスは`object`クラスの子クラスであると同時に、
`object`クラスとしても扱える。
このことから、「`Man`クラスは`object`クラスである」ともいえる。
このような継承関係のことを「is-a」の関係と呼ぶ
(Circle class is a object class)。

シーケンスについても見てみよう。
これらはシーケンス型という大枠に属するが、それぞれが異なる特性を持つ。
   * リスト: 変更可能なシーケンス。任意の型のオブジェクトを要素にできる
   * タプル: 変更不可能なシーケンス。任意の型のオブジェクトを要素にできる
   * 文字列: 変更不可能なシーケンス。Unicodeのコードポイントを要素とする

「インデックスアクセスが可能」「要素のスライスが可能」「反復可能」
といったシーケンスに共通な特徴を持ちながら、
要素にできるオブジェクトの種類が異なったり、
変更ができたりできなかったりする。
これらの継承関係を上と同様な図にすると、概念的には次のように書ける

>         ┌──────┐
>         │変更不可能な│
>         │ シーケンス │
>         └──┬───┘
>       ┌───┴─┬────┐
> ┌──┴──┐┌─┴─┐┌─┴─┐
> │変更可能な││文字列││タプル│
> │シーケンス│└───┘└───┘
> └─┬───┘
> ┌─┴─┐
> │リスト│
> └───┘

変更可能なシーケンスは「変更不可能なシーケンスと共通な特性」を持ち、
それに対して「要素を変更するための属性を付け加えたもの」である。
共通な特性とは「インデックスアクセス」「反復可能」「要素の存在確認」で、
付け加えたものとは「要素への代入」「要素の削除」
などである。
こうしたことを考えると、変更可能なシーケンスは、
変更不可能なシーケンスを継承(拡張)したものだと捉えるのが適切だろう。

ここまでの例から分かるのは次のようなことだ。
   * 親クラス(継承階層で上位に位置するクラス)は
     より抽象的な(多くのクラスで共通する)概念を表現する
   * 子クラス(継承階層で下位に位置するクラス)は
     親クラスが持つ特性を継承して、それを改変したり、拡張したりする
     (抽象的なクラスをより具体的なクラスにしたり、
     特性の異なるさまざまなクラスを定義したりしていく)

クラスを継承するということは、親クラスで既に定義されている属性
(インスタンス変数や各種メソッドなど)が新しいクラスでも適切であれば、
それらを再利用して、そうでなければ独自の属性を定義していくことに
他ならない。

そうすることで、既に書かれたコードを何度も書く必要がなくなると共に、
似た特性を持つクラス群を1つの継承階層の中にまとめることができる。

互いに無関係なクラスに継承関係を持たせることは可能かもしれないが、
そのようなことをするメリットはないのでやめておこう。
継承関係を持たせてもよいのは、上で述べた「is-a」の関係が成立するときだ。

# クラスの継承の基本書式

> 子クラスの定義(クラスの継承)
`class <クラス名>(<親クラス名>[, ...]):
    <クラスブロック>`

> 親クラスを継承して作った子クラスでは、
  親クラスの各種メソッドや変数など、
  定義されたものすべてをそのまま使うことができる

> 子クラスで上書きしたり、
  新たに追加したりしたメソッドは親クラスには影響しない

> <親クラス名>や`()`を省略すると、
  `object`クラスが親クラスとなる。

> `()`内にはカンマ区切りで複数のクラスを指定可能。
  クラスを1つだけ指定する場合を「単一継承」と呼び、
  複数のクラスを指定する場合を「多重継承」と呼ぶ。

```python
class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def hello(self):
        print('Hello,', str(self.name))

    def get_age(self):
        return self.age

# Personクラスを継承
class Student(Person):
    # 初期化メソッドをオーバーライド
    def __init__(self, name, age, school):

        # super()関数の戻り値を介して、Personクラスの__init__メソッドを呼び出して、そこにStudentクラスの__init__メソッドのパラメーターnameとageに渡された値を渡すことで、基底クラスで定義されるインスタンス変数の初期化を行っている
        super().__init__(name, age)
        # self.name = name
        # self.age = age

        # 追加項目
        self.school = school

    # 同名メソッドをオーバライド
    def hello(self):
        super().hello()

        # 追加項目
        print(f'あなたは{self.school}の生徒です')

    # メソッドの追加
    def get_school(self):
        return self.school

# インスタンス作成
kondo = Person('Kondo', 48)
yuuma = Student('Yuuma', 17, '長野高校')

# インスタンスのクラスを取得
print(type(kondo))  # -> <class '__main__.Person'>
print(type(yuuma))  # -> <class '__main__.Student'>

# オーバーライドしたメソッド
kondo.hello()  # -> Hello, Kondo
yuuma.hello()
# Hello, Yuuma
# あなたは長野高校の生徒です

# そのまま継承したメソッド
print(kondo.get_age())  # -> 48
print(yuuma.get_age())  # -> 17

# 追加したメソッド
print(yuuma.get_school())  # -> 長野高校
```

# リンク

[atmarkit.co.jp](https://www.atmarkit.co.jp/ait/articles/1908/09/news035.html)
