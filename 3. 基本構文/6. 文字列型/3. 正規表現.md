# 概要

> Pythonで正規表現の処理を行うには標準ライブラリの`re`モジュールを使う
> 正規表現パターンによる文字列の抽出や置換、分割などができる

## * 関数を使う方法

> 第一引数に正規表現パターンの文字列を指定し、
  その後に処理する文字列などを指定する

```python
import re

target = 'aaa@xxx.com, bbb@yyy.com, ccc@zzz.net'

print(re.match(r'([a-z]+)@([a-z]+)\.com', target))
# -> <re.Match object; span=(0, 11), match='aaa@xxx.com'>
print(re.sub(r'([a-z]+)@([a-z]+)\.com', 'new-address', target))
# -> new-address, new-address, ccc@zzz.net
```

## * 正規表現オブジェクトのメソッドを使う方法

`正規表現オブジェクト = re.compile(正規表現)`
> `re.compile()`を使うと、
  「正規表現パターン文字列」をコンパイルして
  「正規表現オブジェクト」を作成できる。
> 同じパターンを使う処理を繰り返し行う場合は、
  「正規表現オブジェクト」を生成して使い回すほうが効率的

```python
import re

target = 'aaa@xxx.com, bbb@yyy.com, ccc@zzz.net'

"正規表現オブジェクト生成"
pattern = re.compile(r'([a-z]+)@([a-z]+)\.com')
print(pattern)  # -> re.compile('([a-z]+)@([a-z]+)\\.com')
print(type(pattern))  # -> <class 're.Pattern'>

"""`re.match()`, `re.sub()`などの関数と同様の処理が、
「正規表現オブジェクト」のメソッド`match()`, `sub()`として実行できる"""
print(pattern.match(target))
# -> <re.Match object; span=(0, 11), match='aaa@xxx.com'>
print(pattern.sub('new-address', target))
# -> new-address, new-address, ccc@zzz.net
```

> ※以降で説明する`re.xxx()`の関数は
  すべて正規表現オブジェクトのメソッドとしても提供されている

# 抽出

## マッチオブジェクトを返すメソッド

### マッチオブジェクト取得

`(マッチオブジェクト|None) = re.(match|search|fullmatch)
(正規表現, 対象文字列, [フラグ])`

> `match()`: 文字列の先頭にマッチするか
  `search()`: 文字列のどこかにマッチするか
  `fullmatch()`: 文字列全体にマッチするか

> 正規表現モジュール`re`の`match()`・`search()`・`fullmatch()`は、
  文字列が正規表現パターンにマッチした場合、
  マッチした部分をマッチオブジェクトとして返し、
  マッチしなければ、`None`を返す

```python
import re

target = 'aaa@xxx.com'

# === マッチする場合 ===
s_pattern = r'[a-z]+@[a-z]+\.[a-z]+'
match = re.match(s_pattern, target)
print(match)  # -> <re.Match object; span=(0, 11), match='aaa@xxx.com'>
print(type(match))  # -> <class 're.Match'>
print(bool(match))  # -> True

# === マッチしない場合 ===
s_pattern = 'four'
match = re.match(s_pattern, target)
print(match)  # -> None
print(type(match))  # -> <class 'NoneType'>
print(bool(match))  # -> False

# === 文字列のどの部分を対象にマッチングを試みるか ===

target = 'aaa@xxx.com'

s_pattern_1 = r'[a-z]'
s_pattern_2 = r'@[a-z]'
s_pattern_3 = r'[a-z]+@[a-z]+\.[a-z]+'

"先頭"
print(bool(re.match(s_pattern_1, target)))  # -> True
print(bool(re.match(s_pattern_2, target)))  # -> False
print(bool(re.match(s_pattern_3, target)))  # -> True

"任意"
print(bool(re.search(s_pattern_1, target)))  # -> True
print(bool(re.search(s_pattern_2, target)))  # -> True
print(bool(re.search(s_pattern_3, target)))  # -> True

"全体"
print(bool(re.fullmatch(s_pattern_1, target)))  # -> False
print(bool(re.fullmatch(s_pattern_2, target)))  # -> False
print(bool(re.fullmatch(s_pattern_3, target)))  # -> True
```

### マッチオブジェクトで条件分岐

```python
def match(pattern):
    import re
    if re.match(pattern, 'aaa@xxx.com'):
        print('match')
    else:
        print('no match')

match(r'[a-z]+@[a-z]+\.[a-z]+')  # -> match
match(r'[0-9]+')  # -> no match
```

### マッチオブジェクトの情報を取得

#### * グルーピング無し

> マッチオブジェクトの「メソッド」を実行することで
  マッチした文字列を抽出したりその位置を取得したりできる

```python
import re

target = 'aaa@xxx.com'
s_pattern = r'[a-z]+@[a-z]+\.[a-z]+'
match = re.match(s_pattern, target)

"開始位置"
print(match.start())  # -> 0
"終了位置"
print(match.end())  # -> 11
"開始・終了位置のタプル"
print(match.span())  # -> (0, 11)
"文字列情報"
print(match.group())  # -> aaa@xxx.com
```

#### * グルーピング有り

##### * グループ名無し

> グルーピング(かっこで閉じる)した場合、
  各メソッドの「引数」にインデックスを指定すると
  任意のグループを指定して実行できる
    * 省略または0: マッチ全体を指定
    * 1以降の数値: 順番に各グループを指定
    * グループの数より大きい値: エラー

```python
import re

target = 'aaa@xxx.com'
s_pattern = r'([a-z]+)@([a-z]+)\.([a-z]+)'
match = re.match(s_pattern, target)

"開始位置"
print(match.start(0))  # -> 0
print(match.start(1))  # -> 0
print(match.start(2))  # -> 4
print(match.start(3))  # -> 8
# print(match.start(4))  # -> IndexError: no such group

"終了位置"
print(match.end(0))  # -> 11
print(match.end(1))  # -> 3
print(match.end(2))  # -> 7
print(match.end(3))  # -> 11

"開始・終了位置のタプル"
print(match.span(0))  # -> (0, 11)
print(match.span(1))  # -> (0, 3)
print(match.span(2))  # -> (4, 7)
print(match.span(3))  # -> (8, 11)

"マッチした文字列(引数が1つ)"
print(match.group(0))  # -> aaa@xxx.com
print(match.group(1))  # -> aaa
print(match.group(2))  # -> xxx
print(match.group(3))  # -> com

"マッチした文字列(引数が複数)"
print(match.group(0, 1, 2, 3))
# -> ('aaa@xxx.com', 'aaa', 'xxx', 'com')

"グループにマッチした全ての文字列のタプル"
print(match.groups())  # -> ('aaa', 'xxx', 'com')
```

##### * グループ名有り

> `(?P<グループ名>...)`でグルーピングすると、
  インデックスルの代わりにグループ名でグループを指定できる

```python
import re

target = 'aaa@xxx.com'
s_pattern = r'(?P<local>[a-z]+)@(?P<SLD>[a-z]+)\.(?P<TLD>[a-z]+)'
match = re.match( s_pattern, target)

print(match.group('local'))  # -> aaa
print(match.group('SLD'))  # -> xxx
print(match.group('TLD'))  # -> com

"名前を付けても、インデックスで呼び出す事もできる"
print(match.group(1))  # -> aaa
print(match.group(2))  # -> xxx
print(match.group(3))  # -> com

"各グループのグループ名とヒットした文字列を辞書で取得"
print(match.groupdict())
# -> {'local': 'aaa', 'SLD': 'xxx', 'TLD': 'com'}
print(type(match.groupdict()))  # -> <class 'dict'>
```

## マッチ部分すべてを「リスト」で取得

`マッチする文字列のリスト = re.findall(正規表現, 対象文字列[, フラグ])`
> 正規表現パターンでグルーピングすると、
  各グループの文字列を要素とするタプル（`groups()`に相当）のリスト
  が返される
> マッチしない場合は空のリストを返す

```python
import re

target = 'aaa@xxx.com, bbb@yyy.com, ccc@zzz.net'

print(re.findall(r'[a-z]+@[a-z]+\.[a-z]+', target))
# -> ['aaa@xxx.com', 'bbb@yyy.com', 'ccc@zzz.net']
print(re.findall(r'([a-z]+)@([a-z]+)\.([a-z]+)', target))
# -> [('aaa', 'xxx', 'com'), ('bbb', 'yyy', 'com'), ('ccc', 'zzz', 'net')]
print(re.findall(r'[0-9]+', target))  # -> []
```

## マッチ部分すべてを「イテレータ」で取得

`マッチオブジェクトのイテレータ = 
re.finditer(正規表現, 対象文字列, flag=0)`
```python
import re

target = 'aaa@xxx.com, bbb@yyy.com, ccc@zzz.net'
matches = re.finditer(r'[a-z]+@[a-z]+\.[a-z]+', target)
print(matches)
# -> <callable_iterator object at 0x00000260119A12C8>
print(type(matches))
# -> <class 'callable_iterator'>
for match in matches:
    print(match)
# -> <re.Match object; span=(0, 11), match='aaa@xxx.com'>
# -> <re.Match object; span=(13, 24), match='bbb@yyy.com'>
# -> <re.Match object; span=(26, 37), match='ccc@zzz.net'>
```

> マッチするすべての部分の位置を取得
```python
import re

target = 'aaa@xxx.com, bbb@yyy.com, ccc@zzz.net'
print([m.span() for m in re.finditer(r'[a-z]+@[a-z]+\.[a-z]+', target)])
# -> [(0, 11), (13, 24), (26, 37)]
```

# 置換

## マッチする部分を置換た文字列を取得

`置き換えられた文字列 = re.sub
(正規表現, 置換文字列, 対象文字列, count=0, flag=0)`

```python
import re

target = 'aaa@xxx.com, bbb@yyy.com, ccc@zzz.net'
result = re.sub(r'[a-z]+@[a-z]+\.com', 'new-address', target)
print(result)  # -> new-address, new-address, ccc@zzz.net
print(type(result))  # -> <class 'str'>
```

> グルーピングした場合、
 「置換文字列」の中でマッチした文字列を使用可能

> デフォルトでは`\1`, `\2`, `\3`...が、
  それぞれ1つ目の()、2つ目の()、3つ目の()...
  にマッチした部分に対応している

> raw文字列ではない通常の文字列だと
  `\\1`のように`\`をエスケープする必要がある

```python
import re

target = 'aaa@xxx.com, bbb@yyy.com, ccc@zzz.net'
result = re.sub(r'([a-z]+)@([a-z]+)\.com', r'\1@\2.net', target)
print(result)  # -> aaa@xxx.net, bbb@yyy.net, ccc@zzz.net
```

> 正規表現パターンの()の先頭に`?P<xxx>`を記述してグループに名前をつけると、
  `\g<xxx>`のように名前を使って指定できる。

```python
import re

target = 'aaa@xxx.com, bbb@yyy.com, ccc@zzz.net'
result = re.sub(
      r'(?P<local>[a-z]+)@(?P<SLD>[a-z]+)\.com'
    , r'\g<local>@\g<SLD>.net'
    , target
)
print(result)  # -> aaa@xxx.net, bbb@yyy.net, ccc@zzz.net
```

> 引数「count」で最大置換回数（個数）を指定できる
> 左側から「count」個の部分のみ置換される

```python
import re

target = 'aaa@xxx.com, bbb@yyy.com, ccc@zzz.net'
result = re.sub(r'[a-z]+@[a-z]+\.com', 'new-address', target, count=1)
print(result)  # -> new-address, bbb@yyy.com, ccc@zzz.net
```

## 「置換後文字列」と「置換した文字列の数」のタプルを取得

`re.subn(正規表現, 置換文字列, 対象文字列, count=0, flag=0)`

> 置換処理された文字列（`sub()`の返り値と同じ）と
  置換された部分の個数（パターンにマッチした個数）とのタプルを返す

> 引数の指定方法などはsub()と同じ。
  グルーピングした部分を使ったり、
  引数count(最大置換回数)を指定したりできる。

```python
import re

target = 'aaa@xxx.com, bbb@yyy.com, ccc@zzz.net'
result = re.subn(r'[a-z]+@[a-z]+\.com', 'new-address', target)
print(result)  # -> ('new-address, new-address, ccc@zzz.net', 2)

"名前付きグループ使用"
result = re.subn(
      r'(?P<local>[a-z]+)@(?P<SLD>[a-z]+)\.com'
    , r'\g<local>@\g<SLD>.net'
    , target
)
print(result)  # -> ('aaa@xxx.net, bbb@yyy.net, ccc@zzz.net', 2)

"最大置換回数指定"
result = re.subn(r'[a-z]+@[a-z]+\.com', 'new-address', target, count=1)
print(result)  # -> ('new-address, bbb@yyy.com, ccc@zzz.net', 1)
```

# 分割

`list型 = re.split(正規表現, 対象文字列, maxsplit=0, flags=0)`
> パターンで文字列を分割したリストを返す
> 先頭・末尾にマッチする場合、
  結果のリストの最初と最後に空文字列''が含まれる
> 「maxsplit」で最大分割回数（個数）を指定できる。
  左側からcount個の部分でのみ分割される

```python
import re

target = '111aaa222bbb333'

print(re.split('[a-z]+', target))  # -> ['111', '222', '333']
print(re.split('[0-9]+', target))  # -> ['', 'aaa', 'bbb', '']
print(re.split('[a-z]+', target, 1))  # -> ['111', '222bbb333']
```

# フラグの設定

## 文字集合をASCII文字に限定

> 「flags」引数に`re.ASCII`か`re.A`を指定するか、
  「正規表現」の先頭に`(?a)`をつけて指定

> フラグ無:
    `\w`: `[a-zA-Z0-9_]` + 全角の日本語や英数字
    `\d`: `0-9` + 全角の数字
    `\s`: `[ \t\n\r\f\v]` + 全角の空白
    `\W`,`\D`,`\S`: それぞれ`\w`,`\d`,`\s`以外
    `\b`: `\w+`の先頭か末尾の空文字

> フラグ有:
    `\w`: `[a-zA-Z0-9_]`
    `\d`: `0-9`
    `\s`: `[ \t\n\r\f\v]`
    `\W`,`\D`,`\S`: それぞれ`\w`,`\d`,`\s`以外
    `\b`: `\w+`の先頭か末尾の空文字

```python
import re

target = 'aａ1１_＿あ漢 　,+＋'

def flag_test(pattern):
    # target = 'aａ1１_＿あ漢 　,+＋'
    print( '\'', ''.join(re.findall( pattern, target)), '\''
    , sep='')

flag_test(r'\w')  # -> 'aａ1１_あ漢'
flag_test(r'\d')  # -> '1１'
flag_test(r'\s')  # -> ' 　'
flag_test(r'\W')  # -> '＿ 　,+＋'
flag_test(r'\D')  # -> 'aａ_＿あ漢 　,+＋'
flag_test(r'\S')  # -> 'aａ1１_＿あ漢,+＋'

flag_test(r'(?a)\w')  # -> 'a1_'
flag_test(r'(?a)\d')  # -> '1'
flag_test(r'(?a)\s')  # -> ' '
flag_test(r'(?a)\W')  # -> 'ａ１＿あ漢 　,+＋'
flag_test(r'(?a)\D')  # -> 'aａ１_＿あ漢 　,+＋'
flag_test(r'(?a)\S')  # -> 'aａ1１_＿あ漢　,+＋'

print(re.findall(r'\b.+?\b', target))
# -> ['aａ1１_', '＿', 'あ漢']
print(re.findall(r'\b.+?\b', target, flags=re.ASCII))
# -> ['a', 'ａ', '1', '１', '_']
```

## 大文字小文字を区別しない

> 「flags」引数に`re.IGNORECASE`か`re.I`を指定するか、
  「正規表現」の先頭に`(?i)`をつけて指定

> フラグ無:
    大文字小文字が区別される。
    両方にマッチさせるには
    大文字と小文字の両方をパターンに入れる必要がある

> フラグ有:
    大文字小文字を区別せずにマッチする

```python
import re

target = 'abcDEF,ABCefg'
print(re.findall(r'[a-z]+', target))  # -> ['abc', 'efg']
print(re.findall(r'(?i)[a-z]+', target))  # -> ['abcDEF', 'ABCefg']
```

## 各行の先頭・末尾にマッチ

> 「flags」引数に`re.MULTILINE`か`re.M`を指定するか、
  「正規表現」の先頭に`(?m)`をつけて指定

> フラグ無:
    `^`: 「文字列全体」の先頭でマッチ
    `$`: 「文字列全体」の末尾でマッチ

> フラグ有:
    `^`: 「文字列の各行」の先頭でマッチ
    `$`: 「文字列の各行」の末尾でマッチ

```python
import re

target = '''\
abc
efg
xyz
'''

print(re.findall(r'^\w{3}', target))  # -> ['abc']
print(re.findall(r'^\w{3}$', target))  # -> []
print(re.findall(r'\w{3}$', target))  # -> ['xyz']
print(re.findall(r'(?m)^\w{3}', target))  # -> ['abc', 'efg', 'xyz']
print(re.findall(r'(?m)^\w{3}$', target))  # -> ['abc', 'efg', 'xyz']
print(re.findall(r'(?m)\w{3}$', target))  # -> ['abc', 'efg', 'xyz']
```

## 特殊文字「.」を、改行を含むあらゆる文字にマッチさせる

> 「flags」引数に`re.DOTALL`か`re.S`を指定するか、
  「正規表現」の先頭に`(?s)`をつけて指定

> フラグ無:
    `.`: 改行以外のあらゆる文字とマッチ

> フラグ有:
    `.`: 改行を含むあらゆる文字にマッチ

```python
import re

target = '''\
abc
efg
xyz
'''
print(re.findall(r'.+', target))  # -> ['abc', 'efg', 'xyz']
print(re.findall(r'(?s).+', target))  # -> ['abc\nefg\nxyz\n']
```

## re.VERBOSE

> 「flags」引数に`re.VERBOSE`か`re.X`を指定するか、
  「正規表現」の先頭に`(?x)`をつけて指定

> フラグ有:
    正規表現中の空白(半角スペース・タブ・改行)は、
    文字クラス中にあるときと、
    エスケープされていないバックスラッシュの後にあるときと、
    `*?` 、 `(?:` や `(?P<...>` のようなトークン中を除いて無視される

```python
import re
import pprint

target = r'''
    c:\folder\folder2\file.exe
    c:\a\folder\フォルダ 2\file.exe
    c:\ folder\フォルダ 2\file.exe
    c:\folder \フォルダ 2\file.exe
    c:\file.txt d:\file2.txt 
    *:\folder\folder2\file.exe
'''

pattern = re.compile(r'''(?xm)
    \b [a-zA-Z]: \\                 # ドライブ
    (?: \w (?: [\w -]* \w )? \\ )*  # フォルダ
    [\w-]+ \. [a-zA-Z]+ \b          # ファイル
''')

pprint.pprint(pattern.findall(target))
# -> ['c:\\folder\\folder2\\file.exe',
# ->  'c:\\a\\folder\\フォルダ 2\\file.exe',
# ->  'c:\\file.txt',
# ->  'd:\\file2.txt'] 
```

## 複数のフラグを指定

> 複数のフラグを同時に有効にしたい場合は`|`を使う
> インラインフラグの場合は`(?am)`のように各文字を続けて記述する

```python
import re

s = '''aaa-xxx
あああ-んんん
bbb-zzz'''

result = re.findall(r'^\w+', s, flags=re.M | re.A)
print(result)
# ['aaa', 'bbb']

result = re.findall(r'(?am)^\w+', s)
print(result)
# ['aaa', 'bbb']
```

