# 文字列型へ型変換

`str型 = str(オブジェクト)`
> 数値型・コンテナ型オブジェクトなどを文字列へ返還
> たとえば「int型」は16進数、「float型」は指数表記など
  様々な書式で記述できるが、
  `str()`で文字列に変換するとプレーンな書式の文字列に変換される

```python
"整数を文字列へ返還"
print(str(100), type(str(100)))  # -> 100 <class 'str'>
print(str(0xFF), type(str(0xFF)))  # -> 255 <class 'str'>

"小数を文字列へ返還"
print(str(0.123), type(str(0.123)))  # -> 0.123 <class 'str'>
print(str(1.23e+10), type(str(1.23e+10))) # -> 12300000000.0 <class 'str'>

"リスト型を文字列へ返還"
l = [0, 1, 2]
print(str(l), type(str(l))) # -> [0, 1, 2] <class 'str'>

"辞書型を文字列へ返還"
d = {'a': 1, 'b': 2, 'c': 3}
print(str(d), type(str(d))) # -> {'a': 1, 'b': 2, 'c': 3} <class 'str'>
```

# 文字列の長さを取得

## 半角も全角も1文字として扱う場合

`文字列の長さ(int型) = len(対象文字列)`

```python
print(len('abcde'), type(len('abcde')))  # -> 5 <class 'int'>

"全角も半角も1文字として扱われる"
print(len('あいうえお'))                 # -> 5

"エスケープシーケンスはひとつで1文字として扱われる"
print(len('a\tb\\c\nd\n\re'))            # -> 10
"Unicodeエスケープシーケンスも1文字として扱われる"
print(len('\u3042\u3044\u3046'))         # -> 3

"""raw文字列では、特殊文字などに解釈されず、
文字数もそのままカウントされる"""
print(len(r'a\tb\\c\n'))                 # -> 9
print(len(r'\u3042\u3044\u3046'))        # -> 18
```

## 半角を1文字、全角を2文字として扱う場合

`import unicodedata
East Asian Width(str型) = unicodedata.east_asian_width(chr))`
> East Asian Width: 全角・半角かや、文字種を表す文字列

```python
import unicodedata

"全角英数"
print(unicodedata.east_asian_width('Ａ'))  # -> F
"全角かな"
print(unicodedata.east_asian_width('あ'))  # -> W
"半角英数"
print(unicodedata.east_asian_width('a'))   # -> Na
"半角カナ"
print(unicodedata.east_asian_width('ｱ'))   # -> H
"特殊文字(全角)"
print(unicodedata.east_asian_width('Å'))  # -> A

"East Asian Width を利用した文字数取得関数"
def get_east_asian_width_count(text):
    count = 0
    for c in text:
        if unicodedata.east_asian_width(c) in 'FWA':
            "全角文字を2文字としてカウント"
            count += 2
        else:
            count += 1
    return count

print(get_east_asian_width_count('あいうえお'))  # -> 10
print(get_east_asian_width_count('ＡＢＣＤＥ'))  # -> 10
print(get_east_asian_width_count('abcde'))       # -> 5
print(get_east_asian_width_count('ｱｲｳｴｵ'))       # -> 5
print(get_east_asian_width_count('あＡaｧ'))     # -> 6
```

# 置換

## 文字列を指定して置換

`置換後文字列 = 対象文字列.replace(置換元文字列, 置換先文字列[, 最大置換回数])`

```python
s = 'one two one two one'
print(s.replace(' ', '-'))  # -> one-two-one-two-one
"検索文字列削除"
print(s.replace(' ', ''))  # -> onetwoonetwoone
"最大置換回数指定"
print(s.replace(' ', '-', 2))  # -> one-two-one two one
"複数回の置換"
print(s.replace('one', '1').replace('two', '2'))  # -> 1 2 1 2 1

"文字列をスワップ（交換）する関数"
def swap_str(s_target, s1, s2, temp='*q@w-e~r^'):
    return s_target.replace(s1, temp).replace(s2, s1).replace(temp, s2)

print(swap_str(s, 'one', 'two'))  # -> two one two one two

"改行文字を置き換える方法"
s_lines_multi = 'one\ntwo\r\nthree'
print('-'.join(s_lines_multi.splitlines()))  # -> one-two-three
```

## 複数の文字を指定して置換

> 複数の文字(長さ1の文字列)を指定して置換する場合は
  `str.translate()`メソッドを使う

> `translate()`に指定する変換テーブルは`str.maketrans()`メソッドで作成する。

> 変換テーブル用データの表記方法は2種類ある
  ① 辞書型:
    キーに「置換元文字」、
    値に「置換先文字列」もしくは削除を表す`None`を指定
  ② 連結文字列型:
    第1引数に「置換元文字」を連結した文字列、
    第2引数に第1引数と同じ長さの「置換先文字」を連結した文字列、
    第3引数に削除する文字を連結した文字列(省略可能)を指定
    ※置換先文字列に長さ2以上の文字列を指定できない

```python
s = ' A・B、C・D、E・F。 '

"①辞書型"
table = str.maketrans({
    '・': ':',
    '、': ',',
    '。': ' end',
    ' ':  None
})
print(s.translate(table))  # -> A:B,C:D,E:F end

"②連結文字列型"
table = str.maketrans('・、。', ':,.', ' ')
print(s.translate(table))  # -> A:B,C:D,E:F.
```

# 大文字・小文字の操作

## 変換

> アルファベットのような大文字と小文字の区別がある文字であれば
  半角でも全角でも変換される。

> 数字やひらがな・カタカナ・漢字のような
  大文字と小文字の区別がない文字は変化なし

```python
s = 'pYthon iS a gooD proGramming laNguage'

"すべての文字を小文字にする"
print(s.lower())
# ->  python is a good programming language

"すべての文字を大文字にする"
print(s.upper())
# ->  PYTHON IS A GOOD PROGRAMMING LANGUAGE

"先頭の一文字を大文字、他を小文字にする"
print(s.capitalize())
# ->  Python is a good programming language

"単語の先頭の一文字を大文字、他を小文字にする"
print(s.title())
# ->  Python Is A Good Programming Language

"大文字を小文字に、小文字を大文字にする"
print(s.swapcase())
# -> PyTHON Is A GOOd PROgRAMMING LAnGUAGE
```

## 大文字・小文字判定

### すべての文字が「大文字」かどうか判定する

`真偽値 = 対象文字列.isupper()`
> 小文字と大文字の区別がある文字が少なくとも一文字以上含まれていて、
  その全てが「大文字」のときは`True`、それ以外は`False`を返す

```python
print('PYTHON'.isupper())  # -> True
print('python'.isupper())  # -> False
print('Python'.isupper())  # -> False

"全角も小文字大文字の区別がある文字とみなされる"
print('ＰＹＴＨＯＮ'.isupper())  # -> True

"数字やカタカナ、平仮名、漢字などは無視される"
print('PYTHON パイソン 123'.isupper())  # -> True

"小文字と大文字の区別がある文字が含まれていないとFalse"
print('パイソン 123'.isupper())  # -> False
```

### すべての文字が「小文字」かどうか判定する

`真偽値 = 対象文字列.islower()`
> 小文字と大文字の区別がある文字が少なくとも一文字以上含まれていて、
  その全てが「小文字」のときは`True`、それ以外は`False`を返す

```python
print('PYTHON'.islower())  # -> False
print('python'.islower())  # -> True
print('Python'.islower())  # -> False

"全角も小文字大文字の区別がある文字とみなされる"
print('ｐｙｔｈｏｎ'.islower())  # -> True

"数字やカタカナ、平仮名、漢字などは無視される"
print('python パイソン 123'.islower())  # -> True

"小文字と大文字の区別がある文字が含まれていないとFalse"
print('パイソン 123'.islower())  # -> False
```

### タイトルケースか判定する

`真偽値 = 対象文字列.istitle()`
> 文字列がタイトルケース（単語の先頭の一文字が大文字、他は小文字）であればTrue、
  そうでなければFalseを返す。

```python
print('PYTHON Language'.istitle())  # -> False
print('python Language'.istitle())  # -> False
print('Python Language'.istitle())  # -> True

"全角も小文字大文字の区別がある文字とみなされる"
print('Ｐｙｔｈｏｎ Ｌａｎｇｕａｇｅ'.istitle())  # -> True

"""大文字と小文字の区別がない文字を含む場合、
小文字の前に区別がない文字があるとFalseとなる"""
print('★Python Language'.istitle())  # -> True
print('Python★ Language'.istitle())  # -> True
print('Py★thon Language'.istitle())  # -> False

"小文字と大文字の区別がある文字が含まれていないとFalse"
print('パイソン 123'.istitle())  # -> False
```

# 文字列種別判定

```python
"""それぞれの文字種別に
第1引数のすべての文字が当てはまる場合、
その文字種別に「〇」を付ける"""
def str_judge(s):

    def conv_b_to_s(b):
        if b:
            return '○'
        else:
            return '☓'

    "十進数字(半角・全角のアラビア数字)"
    print('decimal:', conv_b_to_s(s.isdecimal()), end=', ')

    "数字(上記の「十進数字」 + 特殊数字)"
    print('digit:', conv_b_to_s(s.isdigit()), end=', ')

    "数(上記の「数字」 + 漢数字・ローマ数字)"
    print('numeric:', conv_b_to_s(s.isnumeric()), end=', ')

    "アルファベット、平仮名、カタカナ、漢数字〇(ゼロ)以外の漢字"
    print('alpha:', conv_b_to_s(s.isalpha()), end=', ')

    "上記のすべて"
    print('alnum:', conv_b_to_s(s.isalnum()))

"数値"
str_judge('1234567890')
# -> decimal: ○, digit: ○, numeric: ○, alpha: ☓, alnum: ○
str_judge('１２３４５６７８９０')
# -> decimal: ○, digit: ○, numeric: ○, alpha: ☓, alnum: ○
str_judge('①②③④⑤⑥⑦⑧⑨')
# -> decimal: ☓, digit: ○, numeric: ○, alpha: ☓, alnum: ○
str_judge('\u00B2')  # 2乗を表す上付き文字
# -> decimal: ☓, digit: ○, numeric: ○, alpha: ☓, alnum: ○
str_judge('ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩ')
# -> decimal: ☓, digit: ☓, numeric: ○, alpha: ☓, alnum: ○
str_judge('一二三四五六七八九')
# -> decimal: ☓, digit: ☓, numeric: ○, alpha: ○, alnum: ○
str_judge('壱億参阡萬')
# -> decimal: ☓, digit: ☓, numeric: ○, alpha: ○, alnum: ○
str_judge('〇')  # 漢数時の0
# -> decimal: ☓, digit: ☓, numeric: ○, alpha: ☓, alnum: ○
"「記号」が入った文字はすべてFalse"
str_judge('1.23')
# -> decimal: ☓, digit: ☓, numeric: ☓, alpha: ☓, alnum: ☓
str_judge('10,000,000')
# -> decimal: ☓, digit: ☓, numeric: ☓, alpha: ☓, alnum: ☓
str_judge('-100')
# -> decimal: ☓, digit: ☓, numeric: ☓, alpha: ☓, alnum: ☓

"文字"
str_judge('abc')
# -> decimal: ☓, digit: ☓, numeric: ☓, alpha: ○, alnum: ○
str_judge('あいうえお')
# -> decimal: ☓, digit: ☓, numeric: ☓, alpha: ○, alnum: ○
str_judge('アイウエオ')
# -> decimal: ☓, digit: ☓, numeric: ☓, alpha: ○, alnum: ○
str_judge('漢字')
# -> decimal: ☓, digit: ☓, numeric: ☓, alpha: ○, alnum: ○
str_judge('')
# -> decimal: ☓, digit: ☓, numeric: ☓, alpha: ☓, alnum: ☓
```

# 寄せ・ゼロ埋め

`右寄せされた文字列 = 対象文字列.rjust(width[, fillchar])`
`左寄せされた文字列 = 対象文字列.ljust(width[, fillchar])`
`中央寄せされた文字列 = 対象文字列.center(width[, fillchar])`
> 第一引数に生成する文字列の文字数を指定する
> デフォルトでは空白（スペース）で埋められる
> 元の文字列の文字数以下の値を指定した場合は
  元の文字列のまま変化なし

```python
s = '1234'

"埋め文字指定無し"
print('"', s.rjust(8), '"', sep='')   # -> "    1234"
print('"', s.ljust(8), '"', sep='')   # -> "1234    "
print('"', s.center(8), '"', sep='')  # -> "  1234  "

"変化なし"
print('"', s.rjust(3), '"', sep='')  # -> "1234"

"埋め文字指定有り"
print('"', s.rjust(8, '_'), '"', sep='')   # -> "____1234"
print('"', s.ljust(8, '_'), '"', sep='')   # -> "1234____"
print('"', s.center(8, '_'), '"', sep='')  # -> "__1234__"

"数値に適用する場合"
print('"', str(1234).rjust(8, '_'), '"', sep='')  # -> "____1234"
```

`ゼロ埋めされた文字列 = 対象文字列.zfill(width)`
> 引数に文字数を指定すると、
  元の文字列が右寄せされて残り
  左側がゼロで埋められた文字列を返す

```python
print('1234'.zfill(8))  # -> 00001234

"""元の文字列の文字数よりも少ない数値を指定した場合は
元の文字列のまま変化なし"""
print('1234'.zfill(3))  # -> 1234

"""「-」または「+」が先頭についている場合、
符号（-, +）のあとからゼロで埋められる。
符号も文字数にカウントされるので注意"""
print('-1234'.zfill(8))  # -> -0001234
print('+1234'.zfill(8))  # -> +0001234

"整数値をゼロ埋めした文字列を生成したい場合"
print(str(1234).zfill(8))  # -> 00001234
```

# 折返し・切詰めして整形

## 折返し

`対象文字列を分割したリスト = textwrap.wrap(対象文字列, width=70, **kwargs)`
`対象文字列を改行した文字列 = textwrap.fill(対象文字列, width=70, **kwargs)`
`**kwargs = max_lines=None, placeholder=' [...]', initial_indent=''`
> 任意の文字数(半角・全角ともに一文字でカウント)に収まるように
  単語の切れ目で、分割
> `max_line`を指定すると、最後に「省略文字列」が入り、
  それ以降の行数は省略される
> デフォルトの省略文字列` [...]`は`placeholder` で変更可能
> `initial_indent`で、最初の行の先頭に加えられる文字列を指定できる

```python
import textwrap

s = """Python can be easy to pick up
 whether you're a first time programmer
 or you're experienced with other languages"""
print(textwrap.wrap(s, 40))
# -> ['Python can be easy to pick up  whether', "you're a first time programmer  or", "you're experienced with other languages"]
print(textwrap.fill(s, 40))
# -> Python can be easy to pick up  whether
# -> you're a first time programmer  or
# -> you're experienced with other languages

print(textwrap.fill(s, 40, max_lines=2))
# -> Python can be easy to pick up  whether
# -> you're a first time programmer  or [...]
print(textwrap.fill(s, 40, max_lines=2, placeholder=' ~'))
# -> Python can be easy to pick up  whether
# -> you're a first time programmer  or ~

print(textwrap.fill(s, 40, initial_indent='  '))
# ->   Python can be easy to pick up  whether
# -> you're a first time programmer  or
# -> you're experienced with other languages
```

## 切り詰め

`切詰められた文字列 = textwrap.shorten(対象文字列, width=70, placeholder=' [...]')`
> 任意の文字数に収まるように末尾から単語が切り捨てられる

```python
import textwrap

s = 'Python is powerful'
print(textwrap.shorten(s, 12))  # -> Python [...]
print(textwrap.shorten(s, 12, placeholder=' ~'))  # -> Python is ~

"日本語の文字列の場合、単語に分割できないのでうまく省略できない"
s = 'Pythonについて。Pythonは汎用のプログラミング言語である。'
print(textwrap.shorten(s, 20))  # -> [...]

"""単語単位ではなく、文字数だけ考慮して省略する場合は、
以下のように簡単に実現できる"""
s_short = s[:12] + ' [...]'
print(s_short)  # -> Pythonについて。P [...]
```

## 決まった設定で上記のメソッドを使う

> 決まった設定で何度も`wrap()`や`fill()` を行う場合は、
  「TextWrapperオブジェクト」を生成しておくと効率が良い

```python
import textwrap

wrapper = textwrap.TextWrapper(width=30,
                               max_lines=3,
                               placeholder=' ~',
                               initial_indent='  ')
s = "Python can be easy to pick up whether you're a first time programmer or you're experienced with other languages"
print(wrapper.wrap(s))
# -> ['  Python can be easy to pick', "up whether you're a first time", "programmer or you're ~"]
print(wrapper.fill(s))
# ->   Python can be easy to pick
# -> up whether you're a first time
# -> programmer or you're ~
```
