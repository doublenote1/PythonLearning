# 増加

## 要素を追加

`None = list型.append(object)`

```python
lst = list(range(3))
print(lst)  # -> [0, 1, 2]
lst.append('appended')
print(lst)  # -> [0, 1, 2, 'appended']
lst.append([0, 1])
print(lst)  # -> [0, 1, 2, 'appended', [0, 1]]
```

`None = set型.add(イミュータブル)`

```python
st = set(range(3))
print(st)  # -> {0, 1, 2}
st.add('added')
print(st)  # -> {0, 1, 2, 'added'}
st.add((0, 1))
print(st)  # -> {0, 1, 2, (0, 1), 'added'}
try:
    st.add([0])
except TypeError as e:
    print(e)  # -> unhashable type: 'list'
```

## 要素を挿入

`None = list型.insert(index, object)`

```python
lst = list(range(3))
print(lst)  # -> [0, 1, 2]
lst.insert(0, 'inserted')
print(lst)  # -> ['inserted', 0, 1, 2]
lst.insert(-1, [0, 1])
print(lst)  # -> ['inserted', 0, 1, [0, 1], 2]
```

## イテラブルを結合

`None = list型.extend(イテラブル)`
> 処理速い

`None = list型 += イテラブル`
> 処理遅い

```python
lst = list(range(2))
print(lst)  # -> [0, 1]
lst.extend([2, 3])
print(lst)  # -> [0, 1, 2, 3]
lst.extend((4, 5))
print(lst)  # -> [0, 1, 2, 3, 4, 5]
lst.extend({6, 7})
print(lst)  # -> [0, 1, 2, 3, 4, 5, 6, 7]
lst.extend({8: 'a', 9: 'b'})
print(lst)  # -> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
lst.extend(range(10, 12))
print(lst)  # -> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
lst.extend('AB')
print(lst)  # -> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 'A', 'B']
```

# 削除

## 指定した値の要素を削除

`None = (list型|set型).remove(x)`
> 存在しない値を指定するとエラー発生

```python
"リスト"
lst = list(range(3))
print(lst)  # -> [0, 1, 2]
lst.remove(2)
print(lst)  # -> [0, 1]
try:
    lst.remove(2)
except ValueError as e:
    print(e)  # -> list.remove(x): x not in list
print()

"セット"
st = set(range(3))
print(st)  # -> {0, 1, 2}
st.remove(2)
print(st)  # -> {0, 1}
try:
    st.remove(5)
except KeyError as e:
    print(e)  # -> 5
print()

"指定した値と同じ要素を全て削除したい時"
lst = [0, 1, 0, 2, 3, 0]
while lst.count(0):
    lst.remove(0)
print(lst)  # -> [1, 2, 3]
```

`None = set型.discard(x)`
> 存在しない値を指定すると何もしない

```python
st = set(range(3))
print(st)  # -> {0, 1, 2}
st.discard(2)
print(st)  # -> {0, 1}
st.discard(2)
print(st)  # -> {0, 1}
```

## 位置指定した要素を取得して削除

`抽出された要素 = list型.pop([index])`

```python
lst = list(range(5))
print(lst)  # -> [0, 1, 2, 3, 4]
print(lst.pop())  # -> 4
print(lst)  # -> [0, 1, 2, 3]
print(lst.pop(0))  # -> 0
print(lst)  # -> [1, 2, 3]
print(lst.pop(-1))  # -> 3
print(lst)  # -> [1, 2]
try:
    print(lst.pop(3))
except IndexError as e:
    print(e)  # -> pop index out of range
```

`抽出された要素 = set型.pop()`
> 要素はランダム抽出される
> set型からはインデックスを指定できない

```python
st = set(range(2))
print(st)  # -> {0, 1}
print(st.pop())  # -> 0
print(st)  # -> {1}
print(st.pop())  # -> 1
print(st)  # -> set()
try:
    print(st.pop())
except KeyError as e:
    print(e)  # -> 'pop from an empty set'
```

## 全ての要素を削除

`None = (list型|set型).clear()`

```python
"リスト"
lst = list(range(3))
print(lst)  # -> [0, 1, 2]
lst.clear()
print(lst)  # -> []

"セット"
st = set(range(3))
print(st)  # -> {0, 1, 2}
st.clear()
print(st)  # -> set()
```

# 並び替え

## 昇順・降順で並び替え

`list型 = sorted(iterable,*,key=None,reverse=False)`
`None = list型.sort(key=None,reverse=False)`

> `key` `reverse`はキーワード引数として指定必須

```python
"イテラブルをリストに変換しソート"
print(sorted([3, 2, 1]))  # -> [1, 2, 3]
print(sorted((3, 2, 1)))  # -> [1, 2, 3]
print(sorted({3, 2, 1}))  # -> [1, 2, 3]
print(sorted({3:'c', 2:'b', 1:'a'}))  # -> [1, 2, 3]
print(sorted({3:'c', 2:'b', 1:'a'}.values()))  # -> ['a', 'b', 'c']
print(sorted({3:'c', 2:'b', 1:'a'}.items()))
# -> [(1, 'a'), (2, 'b'), (3, 'c')]
print(sorted('321'))  # -> ['1', '2', '3']

"「sort」 はリスト型のみをソートできる"
lst = [3, 2, 1]
lst.sort()
print(lst)  # -> [1, 2, 3]
"list型以外をソートしようとするとエラー"
tpl =(3, 2, 1)
try:
    tpl.sort()
except AttributeError as e:
    print(e)  # -> 'tuple' object has no attribute 'sort'

"※以降の例は「sort」も同様"

"引数を省略すると「昇順」"
lst_al = ['c', 'bc', 'abc', 'C', 'BC', 'ABC']
lst_nihongo = [
      '参', '弐', '壱'
    , 'ウ', 'イウ', 'アイウ'
    , 'う', 'いう', 'あいう'
]
lst_num = [123, 23, 3, 0, 0.0, -1, 1, 1.5, -1.5]
lst_snum = ['123', '23', '3', '0', '0.0', '-1', '1', '1.5', '-1.5']
print(sorted(lst_al))
# ->  ['ABC', 'BC', 'C', 'abc', 'bc', 'c']
print(sorted(lst_nihongo))
# ->  ['あいう', 'いう', 'う', 'アイウ', 'イウ', 'ウ', '参', '壱', '弐']
print(sorted(lst_num))
# ->  [-1.5, -1, 0, 0.0, 1, 1.5, 3, 23, 123]
print(sorted(lst_snum))
# ->  ['-1', '-1.5', '0', '0.0', '1', '1.5', '123', '23', '3']

"降順でソート"
print(sorted([1, 2, 3], reverse=True))  # -> [3, 2, 1]

"数値と文字列はソート方法が違う為、一緒にソートできない"
lst_comp = ['123', '23', '3', 123, 23, 3]
try:
    print(sorted(lst_comp))
except TypeError as e:
    print(e)  # -> '<' not supported between instances of 'int' and 'str'

"===並び替え方法指定==="

"文字数で並び替え"
lst = ["Alice", "Bob", "Carl"]
print(sorted(lst, key=len))  # -> ['Bob', 'Carl', 'Alice']

"大文字小文字区別なく並び替え"
lst = ['c', 'bc', 'abc', 'C', 'BC', 'ABC']
print(sorted(lst, key=str.lower))
# -> ['abc', 'ABC', 'bc', 'BC', 'c', 'C']
```

## 逆順で並び替え

`None = list型.reverse()`
`イテレータ = reversed(シーケンス型)`

```python
"逆順で並び替える"
lst = [5, 1, 9, 2, 4]
lst.reverse()
print(lst)  # -> [4, 2, 9, 1, 5]

"逆順で並び替えたイテレータを返す"
lst = [0, 1, 2]
iter_lst = reversed(lst)
print(iter_lst)  # -> <list_reverseiterator object at 0x0000000003917A90>
for i in iter_lst:
    print(i)
# -> 2
# -> 1
# -> 0
word = 'abc'
iter_word = reversed(word)
print(iter_word)  # -> <reversed object at 0x000001E1D0D75088>
for i in iter_word:
    print(i)
# -> c
# -> b
# -> a
```

## ランダムソート（シャッフル）

`None = random.shuffle(list[, random])`

```python
import random

lst = list(range(5))
random.shuffle(lst)
print(lst)  # -> [2, 4, 1, 0, 3]
```

# 情報取得

`指定要素のインデックス = シーケンス型.index(要素[,start[,end]])`

```python
lst = [3, 4, 1, 2, 3, 1, 6, 3, 3]
word = 'strawberry'

print(lst.index(1))  # -> 2
print(lst.index(1, 3))  # -> 5
print(word.index('raw'))  # -> 2

"指定要素が見つからないとエラー"
try:
    print(lst.index(1, 3, 4))
except ValueError as e:
    print(e)  # -> 1 is not in list
```

## 要素の数を取得

`要素数 = len(イテラブル)`
> 全体の要素数

```python
lst = [3, 4, 1, 2, 3, 1, 6, 3, 3]
st = set(lst)
print(st)  # -> {1, 2, 3, 4, 6}
word = 'strawberry'

print(len(lst))  # -> 9
print(len(st))  # -> 5
print(len(word))  # -> 10
```

`要素ごとの出現回数 = シーケンス型.count(x)`
`指定文字列の出現回数 = str型.count(x[,start[,end]])`
> 引数の内容を持った要素の数、もしくは引数の文字列の存在数
> 要素として存在しない値を引数に渡すと0が返る

```python
lst = [3, 4, 1, 2, 3, 1, 6, 3, 3]
word = 'strawberry'

print(lst.count(3))  # -> 4
print(lst.count(10))  # -> 0
print(word.count('r'))  # -> 3
print(word.count('berry'))  # -> 1
print(word.count('r', 3))  # -> 2
print(word.count('r', 8, 9))  # -> 1
```

## 要素全体の計算値を取得

`要素全体の合計値 = sum(iterable[,start])`
`bool型 = any(iterable)`
> リスト要素のいずれかが「True」であれば「True」を返す
`bool型 = all(iterable)`
> リスト要素すべてが「True」であれば「True」を返す

```python
lst = [1, 2, 3, 4, 5]
lst_1_true = [0, 1, 0, 0, 0]
lst_all_false = [0, 0, 0, 0, 0]

"要素全体の合計"
print(sum(lst))  # -> 15

"要素全体の平均値"
print(sum(lst) / len(lst))  # -> 3.0

print(any(lst))  # -> True
print(any(lst_1_true))  # -> True
print(any(lst_all_false))  # -> False

print(all(lst))  # -> True
print(all(lst_1_true))  # -> False
print(all(lst_all_false))  # -> False
```

## 特定の要素を取得

### 最大・最小値

`最(大|小)値 = max|min(iterable,*[,key,default])`
`最(大|小)値 = max|min(arg1,arg2,*args[,key])`

> 下記の例はすべて min にも当てはまる

```python
lst = ['abcd', 'za', 'efg', 'abcd', 'za', 'efg']
lst_0 = []

print(max(lst))  # -> za
print(max(lst, key=len))  # -> abcd
try:
    print(max(lst_0))
except ValueError as e:
    print(e)  # -> max() arg is an empty sequence
print(max(lst_0, default='NOTHING!!!'))  # -> NOTHING!!!
print(max('item000', 'item1', 'item01', key=len))  # -> item000
```

### 最大値・最小値からn個の要素を取得

#### 方法①

> 取得する要素の個数が多い場合に効果的
> 「最大値」からの個数を取得したければ降順、
  「最小値」からの個数を取得したければ昇順でソートし、
  先頭から任意の個数をスライスで選択

```python
lst = [2, 1, 0, -1, -2]
"最大値"
print(sorted(lst, reverse=True)[:2])  # -> [2, 1]
"最小値"
print(sorted(lst)[:2])  # -> [-2, -1]
```

#### 方法②

> 取得する要素の個数が少ない場合に効果的

`import heapq`
`最大値からn個の要素のリスト = heapq.nlargest(n, iterable, key=None)`
`最小値からn個の要素のリスト = heapq.nsmallest(n, iterable, key=None)`

```python
import heapq

lst = [-2, -1, 0, 1, 2]

"最大値からn個の要素のリスト"
print(heapq.nlargest(3, lst))  # -> [2, 1, 0]
"最小値からn個の要素のリスト"
print(heapq.nsmallest(3, lst))  # -> [-2, -1, 0]
```

### ランダムに要素を取得

`import random`

#### 要素を一つ取得

`ランダムに取得された要素 = random.choice(シーケンス)`

```python
import random

lst = list(range(5))
tpl = tuple(range(5))
word = 'ABCDE'

print(random.choice(lst))  # -> 4
print(random.choice(tpl))  # -> 0
print(random.choice(word))  # -> D

"「空」のリストやタプル、文字列を引数として指定するとエラー"
try:
    print(random.choice([]))
except IndexError as e:
    print(e)  # -> Cannot choose from an empty sequence

```

#### 複数の要素を取得(重複なし)

`ランダムに取得された要素のリスト = 
random.sample(population, 取得個数)`
> population: シーケンスまたはセットの意味

```python
import random

lst = list(range(5))
tpl = tuple(range(5))
st = set(range(5))
word = 'ABCDE'

print(random.sample(lst, 3))  # -> [4, 1, 2]
print(random.sample(tpl, 3))  # -> [1, 2, 0]
print(random.sample(st, 3))  # -> [0, 2, 3]
print(random.sample(word, 3))  # -> ['E', 'B', 'D']
```

#### 複数の要素を取得(重複あり)

`random.choices(population,weights=None,*,cum_weights=None,k=1)`
> 引数`(cum_)weights`(list型)で
  それぞれの要素が選ばれる重み（確率）を指定できる
> `(cum_)weights`に指定するリストの要素の型はint型でもfloat型でもOK
> `weights`の要素を0にするとその要素は選ばれない。
> `cum_weights`は累積的な方法で重みを指定
> `weights`と`cum_weights`を同時に指定するとエラー

```python
import random

lst = list(range(5))
print(random.choices(lst, k=3))  # -> [3, 0, 3]
"抽出個数省略"
print(random.choices(lst))  # -> [0]
"抽出個数が「population」の個数を超えてもOK"
print(random.choices(lst, k=10))
# -> [3, 3, 4, 4, 3, 2, 0, 4, 0, 1]

"それぞれの要素が選ばれる重み（確率）を指定"
print(random.choices(lst, k=3, weights=[1, 1, 1, 10, 1]))
# -> [3, 0, 3]
"0にするとその要素は選ばれない"
print(random.choices(lst, k=3, weights=[1, 1, 0, 0, 0]))
# -> [1, 0, 1]
"""累積的な重みとして指定
   以下のサンプルコードの`cum_weights`は上の一つ目の`weights`と等価"""
print(random.choices(lst, k=3, cum_weights=[1, 2, 3, 13, 14]))  # -> [3, 1, 2]

"引数「weights」が引数「population」の個数と一致しないとエラー"
try:
    print(random.choices(lst, k=3, weights=[1, 1, 1, 10]))
except ValueError as e:
    print(e)  # -> The number of weights does not match the population
try:
    print(random.choices(lst, k=3, weights=[1, 1, 1, 10, 1, 1]))
except ValueError as e:
    print(e)  # -> The number of weights does not match the population
"「weights」と「cum_weights」を同時に指定するとエラー"
lst = [1, 2, 3]
try:
    print(random.choices(lst, k=3, weights=[1, 1, 1]
                                 , cum_weights=[1, 2, 3]))
except TypeError as e:
    print(e)  # -> Cannot specify both weights and cumulative weights
```

#### 乱数シードを固定(未完成)

`None = random.seed(a=None, version=2)`
> 乱数シードを固定すると、常に同じ要素が選択される

```python
import random

lst = [0, 1, 2]
# random.seed(0)
for i in range(3):
    print(random.choice(lst))  # -> 3

```
